// This file is part of SSC,
// a C++ Library supporting Image Guided Therapy Applications.
//
// Copyright (C) 2008- SINTEF Medical Technology
// Copyright (C) 2008- Sonowand AS
//
// SSC is owned by SINTEF Medical Technology and Sonowand AS,
// hereafter named the owners. Each particular piece of code
// is owned by the part that added it to the library.
// SSC source code and binaries can only be used by the owners
// and those with explicit permission from the owners.
// SSC shall not be distributed to anyone else.
//
// SSC is distributed WITHOUT ANY WARRANTY; without even
// the implied warranty of MERCHANTABILITY or FITNESS FOR
// A PARTICULAR PURPOSE.
//
// See sscLicense.txt for more information.

#define pixel_pos_c(a,i,c) (pixel_pos[(a)/(bscan_n/5)][((a)-((a)/(bscan_n/5))*(bscan_n/6))*3*mask_size + (i)*3 + (c)])
#define pos_matrices_a(n,x,y) (pos_matrices[(n)*12 + (y)*4 + (x)])
#define inrange(x,a,b) ((x) >= (a) && (x) < (b))
#define volume_a(x,y,z) (volume[(x) + (y)*volume_w + (z)*volume_w*volume_h])

//#include <stdio.h> // debug: enables printf
//#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable // warning: unknown action for '#pragma OPENCL' - ignored
//#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics : enable // warning: unknown action for '#pragma OPENCL' - ignored


#define _distance(v, plane) (plane.x*v.x + plane.y*v.y + plane.z*v.z + plane.w)/sqrt(plane.x*plane.x + plane.y*plane.y + plane.z*plane.z)
#define plane_points_c(n,i) (plane_points[(n)*3 + (i)])

typedef struct _pixel_type
{
	int x;
	int y;
} pixel_type;

/**
 * Find the closest position of the voxel_coord on the plane given by 
 * plane_eq and plane_points. dist is the precomputed distance from voxel_coord
 * to the plane.
 * 
 * The return value is given in frame pixel coordinates (x,y).
 * 
 */
pixel_type findPixel(
		float bscan_spacing_x,
		float bscan_spacing_y,
		__global float4 * plane_eq,
		__global float4 * plane_points,
		int current_bscan,
		float dist,
		float4 voxel_coord
)
{
	// Summarize properties of the current plane:
	float4 normal = { plane_eq[current_bscan].x, plane_eq[current_bscan].y, plane_eq[current_bscan].z, 0.0f};
	float4 corner0 = plane_points_c(current_bscan,0);
	float4 cornerx = plane_points_c(current_bscan,1);
	float4 cornery = plane_points_c(current_bscan,2);

	float4 p = voxel_coord + -dist*normal - corner0;	// vector from frame zero to closest point on frame
	float4 x_vector = normalize(cornerx - corner0);		// unit vector in plane x-direction
	float4 y_vector = normalize(cornery - corner0);		// unit vector in plane y-direction

	pixel_type retval;									// pixel position of closest point
	retval.x = dot(p, x_vector)/bscan_spacing_x;		// pixel x position of closest point
	retval.y = dot(p, y_vector)/bscan_spacing_y;		// pixel y position of closest point
	return retval;
}

/**
 * \brief check if pixel p is valid.
 * 
 * Valid means: Inside mask, inside kernel radius, inside frame.
 */
bool valid_pixel(pixel_type p,
		__global unsigned char * mask,
		int bscan_w,
		int bscan_h,
		float dist,
		float kernel_radius)
{
	return ((p.x >= 0) && (p.x < bscan_w) && (p.y >= 0) && (p.y < bscan_h))
	  && (fabs(dist) < kernel_radius)
	  && (mask[p.x + p.y*bscan_w] != 0);
}

/**
 * Search for another plane closer to the voxel in the 
 * neighbourhood of the starting guess current_bscan.
 *
 * Return the index of the plane.
 *
 * The argument names are mostly the same as for vnn().
 */
int findClosestPlane(
	__global unsigned char * mask, 
	int bscan_w, 
	int bscan_h, 
	int bscan_n, 
	float bscan_spacing_x, 
	float bscan_spacing_y, 
	__global float4 * plane_eq,
	__global float4 * plane_points,	
	int current_bscan, 
	float4 voxel_coord, 
	float kernel_radius
	)
{
	float temp;
	int done_up = 0;
	int done_down = 0;
	int min_bscan = current_bscan;
	int n;

	// dist is the distance from voxel to plane
	float dist = fabs(_distance(voxel_coord, plane_eq[current_bscan]));

	pixel_type p;

	float temp_dist;
	// look in both directions for a hit, we assume the hit is close to the guess.
	for (int i = 1; !done_down || !done_up; i++)
	{
		if (!done_up)
		{
			n = current_bscan + i;
			temp_dist = fabs(_distance(voxel_coord, plane_eq[n]));

			if (temp_dist < dist)
			{
				pixel_type p_temp = findPixel(bscan_spacing_x, bscan_spacing_y, 
				                              plane_eq, plane_points, n, dist, voxel_coord);
				if (valid_pixel(p_temp, mask, bscan_w, bscan_h, 
				                temp_dist, kernel_radius))
				{
					p = p_temp;
					min_bscan = n;
					dist = temp_dist;
				}
			}
			done_up = temp_dist-dist > kernel_radius || n >= bscan_n-1;

		}

		if (!done_down)
		{
			n = current_bscan - i;
			temp_dist = fabs(_distance(voxel_coord, plane_eq[n]));

			if (temp_dist < dist)
			{
				pixel_type p_temp = findPixel(bscan_spacing_x, bscan_spacing_y, 
				                              plane_eq, plane_points, n, dist, voxel_coord);
				if (valid_pixel(p_temp, mask, bscan_w, bscan_h, 
				                temp_dist, kernel_radius))
				{
					p = p_temp;
					min_bscan = n;
					dist = temp_dist;
				}
			}
			done_down = temp_dist-dist > kernel_radius || n <= 0;
		}
	}

	return min_bscan;
}


/**
 * \brief openCL kernel for vnn reconstruction.
 * 
 * \param mask    			Binary mask frame with same dimensions as a single 
 *                			input frame.
 * \param bscan_w 			Width of input frames in pixels
 * \param bscan_h 			Height of input frames in pixels
 * \param bscan_n 			Number of input frames
 * \param bscan_spacing_x 	Pixel x spacing of input frames 
 * \param bscan_spacing_y 	Pixel y spacing of input frames 
 * \param volume 			Target volume.
 * \param volume_n			Depth (z) of target volume in pixels
 * \param volume_h			Height (y) of target volume in pixels
 * \param volume_w			Width (x) of target volume in pixels
 * \param volume_spacing	Pixel spacing (all axes) of target volume
 * \param plane_eq			Plane equations (N*r+d=0) for each frame.
 * \param plane_points		Triplets of points describing each frame. The 
 *                          triplet is the corners (0,0)(1,0)(0,1) of the 
 *                          frame in target volume space. 
 * \param printings			not used
 * \param section			not used
 * \param kernel_radius		Maximum allowed distance from a voxel to a frame, 
 *                 			in order to use that frame in that voxel.
 * \param frameBlock0		Input frame data. Due to mimitations in hw, the 
 *              			data is split into 10 blocks of equal size. 
 *
 * Terminology: 
 *  - Frame: One input ultrasound image. Also called bscan.
 *  - Mask: Binary frame that defines which pixels on each frame that is valid.
 *  - Plane: The plane in 3D that describes the position of a frame. Defined by
 *    a plane equation and a bounding box.
 *  - Target volume: The volume that data is reconstructed into.
 *
 * One kernel processes all voxels for a fixed (x,z)-pair, i.e. for all values
 * of y. The global id is used for this, and is assumed to be in the range
 * <0..(volume_w*volume_n)>.
 *
 * For each voxel, the closest plane is found, and the intensity from the 
 * closest point on the frame is inserted into the voxel. The plane must be 
 * closer to the voxel than kernel_radius in order to be accepted.
 *
 */
__kernel void vnn(__global unsigned char * mask,
		int bscan_w,
		int bscan_h,
		int bscan_n,
		float bscan_spacing_x,
		float bscan_spacing_y,
		__global unsigned char * volume,
		int volume_n,
		int volume_h,
		int volume_w,
		float volume_spacing,
		__global float4 * plane_eq,
		__global float4 * plane_points,
		__global float * printings,
		int section,
		float kernel_radius,
		__global unsigned char * frameBlock0,
		__global unsigned char * frameBlock1,
		__global unsigned char * frameBlock2,
		__global unsigned char * frameBlock3,
		__global unsigned char * frameBlock4,
		__global unsigned char * frameBlock5,
		__global unsigned char * frameBlock6,
		__global unsigned char * frameBlock7,
		__global unsigned char * frameBlock8,
		__global unsigned char * frameBlock9)
{

	// Extract (x,z) coordinates. The kernel works on this y-column.
	int id = get_global_id(0);
	int z = id/volume_w;
	int x = id%volume_w;
	if (z >= volume_n) return;
	if (x >= volume_w) return;

	//float kernel_radius = volume_spacing*4;

	// Find plane closest to voxel (x,0,z).
	// This is used as a starting guess for the closest plane for all y.
	int current_bscan = -1;
	float dist = 10000; // inf
	for (int n = 0; n < bscan_n; n++)
	{
		float4 voxel_000 =
		{	x*volume_spacing, 0.0f, z*volume_spacing, 0.0f};
		float temp = fabs(_distance(voxel_000, plane_eq[n]));
		if (temp < dist)
		{
			current_bscan = n;
			dist = temp;
		}
	}

	// Iterate over all voxels in the (x,z)-column
	// For each voxel, find the closest plane, find the closest point from the voxel 
	// to the plane, then lookup the intensity value from the corresponding frame.
	for (int y = 0; y < volume_h; y++)
	{
		// voxel coordinate in target coordinates
		float4 voxel_coord = { x*volume_spacing, y*volume_spacing, z*volume_spacing, 0.0f};

		current_bscan = findClosestPlane(mask, 
		                                 bscan_w, bscan_h, bscan_n, 
		                                 bscan_spacing_x, bscan_spacing_y, 
		                                 plane_eq, plane_points, 
		                                 current_bscan, 
		                                 voxel_coord, 
		                                 kernel_radius);

		// give up current voxel if no plane found
		if (current_bscan == -1)
			continue;

		// Recompute distance from voxel_coord to plane
		dist = _distance(voxel_coord, plane_eq[current_bscan]);
		// p is the closest point on the frame, in frame (pixel) coordinates.
		pixel_type p;
		p = findPixel(bscan_spacing_x, bscan_spacing_y, plane_eq, plane_points, current_bscan, dist, voxel_coord);

		//printf("current_bscan: %d, px: %d, py: %d, z: %d\n", current_bscan, px, py, z);

		// give up current voxel if p is not valid
		if(!valid_pixel(p, mask, bscan_w, bscan_h, dist, kernel_radius))
			continue;

		// Now lookup the intensity value of the pixel p in frame current_bscan.
		// This involves finding the correct memory block and indexing into that block.
		int numBlocks = 10;
		int framePos = current_bscan/numBlocks; // First position of the current frame in the frameBlock
		int pixelPos = p.x + p.y*bscan_w; // Pixel position in the frame
		int frameSize = bscan_w*bscan_h;
		int totPixelPos = framePos*frameSize + pixelPos; // Pixel position in frameBlock 
		unsigned char pixelVal; // The read pixel value
		int devReminder = current_bscan%numBlocks;
		//Select correct frameBlock
		switch(devReminder) // Need to have a case for each number (numBlocks)
		{
			case 0 :
				pixelVal = frameBlock0[totPixelPos];
				break;
			case 1 :
				pixelVal = frameBlock1[totPixelPos];
				break;
			case 2:
				pixelVal = frameBlock2[totPixelPos];
				break;
			case 3:
				pixelVal = frameBlock3[totPixelPos];
				break;
			case 4:
				pixelVal = frameBlock4[totPixelPos];
				break;
			case 5:
				pixelVal = frameBlock5[totPixelPos];
				break;
			case 6:
				pixelVal = frameBlock6[totPixelPos];
				break;
			case 7:
				pixelVal = frameBlock7[totPixelPos];
				break;
			case 8:
				pixelVal = frameBlock8[totPixelPos];
				break;
			case 9:
				pixelVal = frameBlock9[totPixelPos];
				break;
			default : // case 0
				pixelVal = frameBlock0[totPixelPos];
				//printf("Warning: Number of frame blocks are not correct/n");
		}

		pixelVal = max((uchar)1, pixelVal); // set minimum intensity value to 1. This separates "zero intensity" from "no intensity".
		volume_a(x,y,z) = pixelVal;  // assign intensity to target volume. 

		//	volume_a(x,y,z) = 255; //testcode - if you want to display entire 'hit' volume as white.

	} // end iterate over all voxels in (x,z)-column

}
