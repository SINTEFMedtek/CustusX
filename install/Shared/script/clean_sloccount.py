#!/usr/bin/env python

#####################################################
# Unix setup script
# Author: Christian Askeland, SINTEF Medical Technology
# Date:   2013.01.30
#
# Description:
#
#             
#################################################             

import subprocess
import optparse
import re
import sys
import os.path
import urllib
import getpass
import platform
import os
import time
import webbrowser


class Common(object):
    '''
    Container for common data.
    Modify these to change behaviour
    '''
    def __init__(self):
	pass
# ---------------------------------------------------------
    
class Shell (object):
    '''
    Superclass for platform specific shells like:
    -cmd (Windows)
    -bash (Mac & Linux)
    '''
    def __init__(self):
        self.DUMMY = False
        self.VERBOSE = False
        self.CWD = '/' # remember directory
        self.password = ""
        
    def _runReal(self, cmd):
        '''This function runs shell, no return, insert password'''
        print '*** run:', cmd
        p = subprocess.Popen(cmd, shell=True, cwd=self.CWD)
        p.communicate("") # seems to be needed in order to wait for password prompting...?
    
    def _runDummy(self, cmd):
        '''Dummy version of shell'''
        if cmd=="whoami":
            #return self._runReal(cmd) #does not work as expected on windows
            return DATA.mUser
        print "*** dummy run:", cmd
        return ""
    
    def run(self, cmd):
        '''Run a shell script'''
        if self.DUMMY is True:
            return self._runDummy(cmd)
        else:
            return self._runReal(cmd)
           
    def evaluate(self, cmd):
        '''This function takes shell commands and returns them'''
        # print '*** eval run:', cmd
        p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, cwd=self.CWD)
        out = p.stdout.read().strip()
        return out #This is the stdout from the shell command
    
    def changeDir(self, path):
        self.CWD = path
    
# ---------------------------------------------------------
    
class Bash (Shell):
    '''
    Wrapper for methods that call the bash shell.
    Also keeps track of the current directory through changeDir()
    '''
    def __init__(self):
        super(Bash, self).__init__()
    
    def changeDir(self, path):
        '''mkdir + cd bash operations'''
        path = path.replace("\\", "/")
        #Shell.run(self, 'mkdir -p '+path)
        Shell.changeDir(self, path)

# --------------------------------------------------------

shell = Bash() 
# shortcuts
runShell = shell.run
changeDir = shell.changeDir

# ---------------------------------------------------------


def packageTextAsHTML(heading, body, filename):
	"""
	Create a minimal html file containgin header and body
	"""
	skeleton = """\
<!DOCTYPE html>
<html>
<body>
<h1>%s</h1>
<p>%s</p>
</body>
</html>
"""
	body = '&nbsp&nbsp&nbsp&nbsp&nbsp'.join(body.split('\t'))
	body = '<br>'.join(body.split('\n'))
	#print body
	text = skeleton % (heading, body)
	f = open(filename, 'w')
	f.write(text)
	f.close()
	return filename

class Controller(object):
	'''
	A command line program that parses options and arguments,
	then performs the requested operations on the selected
	components.
	'''
	def __init__(self):
		'''
		Initialize and run the controller
		'''        
		self.optionParser = self._createOptionParser();
		self._parseCommandLine()
    
	def _createOptionParser(self):
		"""
		"""
		description='''
		Remove parts of output generated by sloccount.
		'''        
		#Create instance of OptionParser Module, included in Standard Library
		p = optparse.OptionParser(description=description,
				            version='%prog version 0.1',
				            usage= '%prog [options] [filename_in] [filename_out]')
		p.add_option('--remove', '-r',
			     action='store',
			     type='string',
			     help='whitespace-separated list of string to remove',
			     default="")
		return p
    
	def _parseCommandLine(self):
		'''
		Parse the options and arguments from the command line
		'''
		options, arguments = self.optionParser.parse_args()

		infile = ''
		outfile = ''
		if len(arguments)>1:
			infile = arguments[0]
			outfile = arguments[1]
		# display help if no path set
		if len(infile)==0:
			self.optionParser.print_help()
			return

		filters = options.remove.split(' ')
		print 'removing all lines in %s containing one of:\n%s' % (infile, '\n'.join(filters))

		with open(infile, 'r') as f:
			read_data = f.read()

		
		lines = read_data.split('\n')
		cleanlines = [x for x in lines if not self._contained(x, filters)]
		out_text = '\n'.join(cleanlines) + '\n'

		# write to outfile
		f = open(outfile, 'w')
		f.write(out_text)
		f.close()

	def _contained(self, line, filters):
		'''
		return true is line contains one of the filters
		'''
		for onefilter in filters:
			if onefilter in line:
				#print "RM [%s]:[%s]" % (onefilter, line)
				return True
		return False

	


def main():
    Controller()

#This idiom means the below code only runs when executed from command line
if __name__ == '__main__':
    main()

