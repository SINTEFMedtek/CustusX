

// At current, this is a temporary playground file for Tord

typedef struct _close_plane
{
	float dist;
	int plane_id;
} close_plane_t;

#define MAX_PLANES 24
#define N_BLOCKS 10

#define METHOD_VNN 0
#define METHOD_VNN2 1

#define VOXEL(v,x,y,z) v[x + y*volume_xsize + z*volume_ysize*volume_xsize]

//#define DEBUG

#ifdef DEBUG

#define DEBUG_PRINTF(...) printf(##__VA_ARGS__)

#else

#define DEBUG_PRINTF(...)

#endif

/*
float plane_dist(const float4 voxel, const float16 matrix)
{
	//	float4 z_axis = matrix.s89AB;
	float4 z_axis = matrix.s26AE;
		z_axis.w = 0.0f;
	float4 trans = matrix.s37BF;
	//	voxel.w = 1;
	return dot(z_axis, voxel) - dot(z_axis, trans);
}
*/

#define plane_dist(voxel, matrix) (dot(matrix.s26AE,voxel) - dot(matrix.s26AE, matrix.s37BF))
/*
float4 projectOntoPlane(const float4 voxel, const float16 matrix, const float dist)
{
	float4 z_axis = matrix.s26AE;
	
	return voxel - dist*(voxel * z_axis); 
	} */

#define projectOntoPlane(voxel, matrix, dist) (voxel - dist*(voxel * matrix.s26AE))
	
	
/** Find all planes that are within radius of voxel.
    Perform a simple linear search for now.
    May need to optimize this.
    It spends ~50% of the time in here!
*/
int
findClosePlanes(close_plane_t *close_planes,
                __global float16* const plane_matrices,
                int n_planes,
                float4 voxel,
                float radius,
                int* guess)
{

	int found = 0;
	voxel.w = 1;
	int2 done = {0,0};
	int smallest_idx = *guess;
	float2 dists; // .x = dist_up, .y = dist_down
	float2 abs_dists; // .x = abs_dist_up, .y = abs_dist_down,
	//	float2 prev_dists; // .x = abs_prev_dist_up, .y = abs_prev_dist_down
	float smallest_dist = 99999.9f;

	
	for(int i = 0; !done.x || !done.y ; i++)
	{
		int2 idx;
		idx.x = *guess + i;
		idx.y = *guess - i;
		dists.x = plane_dist(voxel,plane_matrices[idx.x]);
		dists.y = plane_dist(voxel,plane_matrices[idx.y]);
		//	prev_dists = abs_dists;
		abs_dists.x = fabs(dists.x);
		abs_dists.y = fabs(dists.y);

		if(!done.x && abs_dists.x < radius)
		{			
			close_planes->dist = dists.x;
			close_planes->plane_id = idx.x;
			close_planes++;
			found++;
			if(smallest_dist > abs_dists.x)
			{
				smallest_idx = idx.x;
				smallest_dist = abs_dists.x;
			} 
		}

		if(!done.y && abs_dists.y < radius)
		{
			close_planes->dist = dists.y;
			close_planes->plane_id = idx.y;
			close_planes++;
			found++;
			if(smallest_dist > abs_dists.y)
			{
				smallest_idx = idx.y;
				smallest_dist = abs_dists.y;
			} 
		}


		int2 term_dists = {abs_dists.x > 2.0f*radius, abs_dists.y > 2.0f*radius };

		int2 term_boundaries = {idx.x == n_planes-1, idx.y == 0};
				
		done = done + (found >= MAX_PLANES) + term_dists + term_boundaries;
		
		/*
		done.x = done.x || (abs_dists.x - prev_dists.x > 2.0f) || idx.x == n_planes-1 || found >= MAX_PLANES;
		done.y = done.y || (abs_dists.y - prev_dists.y > 2.0f) || idx.y == 0 || found >= MAX_PLANES;
		*/
	
	}
	
	*guess = smallest_idx;
	return found;
}


__global const unsigned char*
getImageData(int plane_id,
             __global const unsigned char* bscans_blocks[],
             int in_xsize,
             int in_ysize,
             int n_planes)
{
	int scans_per_block = n_planes / N_BLOCKS;
	int n_big_blocks = n_planes % N_BLOCKS;
	int block, idx_in_block;
	// Check if plane is in one of the big blocks
	if(plane_id < n_big_blocks * (scans_per_block+1))
	{
		// It's in a big block
		block = plane_id / (scans_per_block+1);
		idx_in_block = plane_id % (scans_per_block+1);
	}
	else
	{
		// It's in a small block
		int index_into_small_blocks = plane_id - (n_big_blocks * (scans_per_block+1));
		idx_in_block = index_into_small_blocks % scans_per_block;
		block = n_big_blocks + (index_into_small_blocks / scans_per_block);
	}
	return &bscans_blocks[block][idx_in_block*in_xsize*in_ysize];
}

float4 transform(float16 matrix,
                 float4 voxel)
{
	float4 ret;
	
	ret.x = matrix.s0*voxel.x + matrix.s1*voxel.y + matrix.s2*voxel.z + matrix.s3;
	ret.y = matrix.s4*voxel.x + matrix.s5*voxel.y + matrix.s6*voxel.z + matrix.s7;
	ret.z = matrix.s8*voxel.x + matrix.s9*voxel.y + matrix.sA*voxel.z + matrix.sB;
	
	ret.w = 1.0f;
	return ret;

}
float4 transform_inv(float16 matrix,
                     float4 voxel)
{
	float4 ret;
	float4 col0 = matrix.s048C;
	float4 col1 = matrix.s159D;
	float4 col2 = matrix.s26AE;
	float4 col3 = matrix.s37BF;
	
	ret.x = dot(voxel,col0) - dot(col3,col0);
	ret.y = dot(voxel,col1) - dot(col3,col1);
	ret.z = dot(voxel,col2) - dot(col3,col2);
	
	/*ret.x = dot(voxel,col0);
	ret.y = dot(voxel,col1);
	ret.z = dot(voxel,col2);

	ret -= col3; */
	return ret;
}

/*
void printMatrix(float16 matrix)
{
	printf("[ %f, %f, %f, %f\n   %f, %f, %f, %f\n   %f, %f, %f, %f\n   %f, %f, %f, %f\n",
	       matrix.s0,
	       matrix.s1,
	       matrix.s2,
	       matrix.s3,
	       matrix.s4,
	       matrix.s5,
	       matrix.s6,
	       matrix.s7,
	       matrix.s8,
	       matrix.s9,
	       matrix.sA,
	       matrix.sB,
	       matrix.sC,
	       matrix.sD,
	       matrix.sE,
	       matrix.sF);
}
*/
	       


void toImgCoord(int* x,
                int* y,
                float4 voxel,
                float16 plane_matrix,
                float in_xspacing,
                float in_yspacing)
{
	DEBUG_PRINTF("Voxel: %f, %f, %f, %f\n",voxel.x, voxel.y, voxel.z, voxel.w);

	float4 transformed_voxel = transform_inv(plane_matrix, voxel);

	*x = transformed_voxel.x/in_xspacing;
	*y = transformed_voxel.y/in_yspacing;
}


int isValidPixel(int x, int y, int in_xsize, int in_ysize)
{
	if(x < 0 || x >= in_xsize)
	{
		return 0;
	}
	if( y < 0 || y >= in_ysize)
	{
		return 0;
	}
	return 1;
}

unsigned char
performInterpolation_vnn(close_plane_t *close_planes,
                         int n_close_planes,
                         __global const float16  *plane_matrices, 
                         __global const unsigned char* bscans_blocks[],
                         int in_xsize,
                         int in_ysize,
                         float in_xspacing,
                         float in_yspacing,
                         float4 voxel,
                         int n_planes)
{
                                      

	if(n_close_planes == 0) return 1;
	

	int plane_id = 0;
	float lowest_dist = 10.0f;
	int close_plane_id = 0;
	for(int i = 0; i < n_close_planes;  i++)
	{
		if(fabs(close_planes[i].dist) < fabs(lowest_dist))
		{
			lowest_dist = close_planes[i].dist;
			plane_id = close_planes[i].plane_id;
			close_plane_id = i;
		}
	} 
			
	const __global unsigned char* image = getImageData(plane_id,
	                                                   bscans_blocks,
	                                                   in_xsize,
	                                                   in_ysize,
	                                                   n_planes); 

	// Now we project the voxel onto the plane by translating the voxel along the
	// normal vector of the plane.
	
	float4 translated_voxel = projectOntoPlane(voxel,
	                                           plane_matrices[plane_id],
	                                           close_planes[close_plane_id].dist);
	
	
	
	// And then we get the pixel space coordinates
	int x, y;
	toImgCoord(&x,
	           &y,
	           voxel,
	           plane_matrices[plane_id],
	           in_xspacing,
	           in_yspacing);

	if(!isValidPixel(x,y, in_xsize, in_ysize))
	{
		return 1;
	}
	return max((unsigned char)1, image[y*in_xsize + x]);
	//return n_close_planes;
	//return (unsigned char)(x % 255);
}


unsigned char
performInterpolation_vnn2(close_plane_t *close_planes,
                          int n_close_planes,
                          __global const float16  *plane_matrices, 
                          __global const unsigned char* bscans_blocks[],
                          int in_xsize,
                          int in_ysize,
                          float in_xspacing,
                          float in_yspacing,
                          float4 voxel,
                          int n_planes)
{
                                      

	if(n_close_planes == 0) return 1;
	

	float scale = 0.0f;
	
	float val = 0;
	for(int i = 0; i < n_close_planes; i++)
	{

		int plane_id = close_planes[i].plane_id;
		const __global unsigned char* image = getImageData(close_planes[i].plane_id,
		                                             bscans_blocks,
		                                             in_xsize,
		                                             in_ysize,
		                                             n_planes);


		// Now we project the voxel onto the plane by translating the voxel along the
		// normal vector of the plane.
	
		float4 translated_voxel = projectOntoPlane(voxel,
		                                           plane_matrices[plane_id],
		                                           close_planes[i].dist);
	
	
		// And then we get the pixel space coordinates
		int x, y;
		toImgCoord(&x,
		           &y,
		           translated_voxel,
		           plane_matrices[plane_id],
		           in_xspacing,
		           in_yspacing);

		if(!isValidPixel(x,y, in_xsize, in_ysize))
		{
			continue;
		}
		float dist = fabs(close_planes[i].dist);
		scale += 1.0f/dist;
		val += (image[y*in_xsize + x] * 1.0f/dist);
	}		

	
	return (unsigned char) (val / scale);
	
}


unsigned char
performInterpolation(close_plane_t *close_planes,
                     int n_close_planes,
                     __global const float16  *plane_matrices, 
                     __global const unsigned char* bscans_blocks[],
                     int in_xsize,
                     int in_ysize,
                     float in_xspacing,
                     float in_yspacing,
                     float4 voxel,
                     int n_planes,
                     int method
	)
{
	unsigned char value = 0;
	if(method == METHOD_VNN)
	{
		value = performInterpolation_vnn(close_planes,
		                                 n_close_planes,
		                                 plane_matrices,
		                                 bscans_blocks,
		                                 in_xsize,
		                                 in_ysize,
		                                 in_xspacing,
		                                 in_yspacing,
		                                 voxel,
		                                 n_planes);
	} else if (method == METHOD_VNN2)
	{
		value = performInterpolation_vnn2(close_planes,
		                                  n_close_planes,
		                                  plane_matrices,
		                                  bscans_blocks,
		                                  in_xsize,
		                                  in_ysize,
		                                  in_xspacing,
		                                  in_yspacing,
		                                  voxel,
		                                  n_planes);
	}
	return max((unsigned char)1,value);
}
	

__kernel void
voxel_methods(int volume_xsize,
              int volume_ysize,
              int volume_zsize,
              float volume_xspacing,
              float volume_yspacing,
              float volume_zspacing,
               int in_xsize,
              int in_ysize,
              int n_planes,
              float in_xspacing,
              float in_yspacing,
              // TODO: Wouldn't it be kind of nice if the bscans was an image sampler object?
              __global unsigned char* in_bscans_b0,
              __global unsigned char* in_bscans_b1,
              __global unsigned char* in_bscans_b2,
              __global unsigned char* in_bscans_b3,
              __global unsigned char* in_bscans_b4,
              __global unsigned char* in_bscans_b5,
              __global unsigned char* in_bscans_b6,
              __global unsigned char* in_bscans_b7,
              __global unsigned char* in_bscans_b8,
              __global unsigned char* in_bscans_b9,
              __global unsigned char* out_volume,
              __global float16 *plane_matrices, 
              float radius,
              int method
	)
{

	int id = get_global_id(0);
	int x = id % volume_xsize;
	int z = id / volume_xsize;

	// Aggregate pointers to the bscan blocks into one array for convenience
	
	const __global unsigned char *bscans_blocks[] = { in_bscans_b0,
	                                            in_bscans_b1,
	                                            in_bscans_b2,
	                                            in_bscans_b3,
	                                            in_bscans_b4,
	                                            in_bscans_b5,
	                                            in_bscans_b6,
	                                            in_bscans_b7,
	                                            in_bscans_b8,
	                                            in_bscans_b9 };
	                             
	// Return if x/z is invalid
	
	if(z >= volume_zsize) return;
	if(x >= volume_xsize) return;
	
	// For most of these algorithms we need to find some set of close planes.
	// We find all planes that are inside the voxel radius
	close_plane_t close_planes[MAX_PLANES];
	int n_close_planes;
	int guess = 0;
	float4 voxel = {x * volume_xspacing,
	                0.0f,
	                z * volume_zspacing,
	                1.0f};
	// Find the plane closest to the initial voxel
	float smallest_dist = 99999999.9f;
	float dist;
	for(int i = 0; i < n_planes; i++)
	{
		dist = fabs(plane_dist(voxel,plane_matrices[i]));
		if(dist < smallest_dist)
		{
			smallest_dist = dist;
			guess = i;
		}
	}
	
	// Iterate over Y axis
	for(int y = 0; y < volume_ysize; y++)
	{
		voxel.y += volume_yspacing;

		// Find all planes closer than radius
		n_close_planes = findClosePlanes(close_planes, plane_matrices, n_planes, voxel, radius,
		                                 &guess);
		
		// Call appropriate method to determine pixel value
		VOXEL(out_volume,x,y,z) = performInterpolation(close_planes,
		                                               n_close_planes,
		                                               plane_matrices,
		                                               bscans_blocks,
		                                               in_xsize,
		                                               in_ysize,
		                                               in_xspacing,
		                                               in_yspacing,
		                                               voxel,
		                                               n_planes,
		                                               method);
		//VOXEL(out_volume, x, y, z) = ((float)z/(float)volume_zsize) * 255;
		//VOXEL(out_volume, x,y,z) = 1;
		
	}
}
	
