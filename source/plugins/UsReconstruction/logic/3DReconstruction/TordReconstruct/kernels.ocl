

// At current, this is a temporary playground file for Tord

/*******************/
/* Begin constants */
/*******************/

#define MAX_PLANES_WITHIN_RADIUS 100
#define N_BLOCKS 10

// Reconstruction methods
#define METHOD_VNN 0
#define METHOD_VNN2 1
#define METHOD_DW 2
#define METHOD_ANISOTROPIC 3

// Plane searching methods
#define PLANE_HEURISTIC 0
#define PLANE_CLOSEST 1


// Anisotropic method specific constants
#define ANISOTROPIC_SIZE 3
#define ANISOTROPIC_GAUSSIAN_SIZE 3

#define ANISOTROPIC_METHOD_INCLUDE_ALL 0
#define ANISOTROPIC_METHOD_BILINEAR_ON_PLANE 1
#define ANISOTROPIC_METHOD_GAUSSIAN_ON_PLANE 2


#define ANISOTROPIC_METHOD ANISOTROPIC_METHOD_INCLUDE_ALL

/*****************/
/* End constants */
/*****************/


/****************/
/* Begin macros */
/****************/

//#define DEBUG

#ifdef DEBUG
#define DEBUG_PRINTF(...) if((get_global_id(0) % 5000) == 0) printf(##__VA_ARGS__)
//#define DEBUG_PRINTF(...) printf(##__VA_ARGS__)
#else
#define DEBUG_PRINTF(...)
#endif


#define plane_dist(voxel, matrix) (dot(matrix.s26AE,voxel) - dot(matrix.s26AE, matrix.s37BF))

#define projectOntoPlane(voxel, matrix, dist) (voxel - dist*(matrix.s26AE))

#define projectOntoPlaneEq(voxel, eq, dist) (voxel - dist*(eq))

#define isInside(x, size) ((x) >= 0 && (x) < (size))
//#define isNotMasked(x, y, mask, xsize) ((mask)[(x) + (y)*(xsize)] > 0)
#define isNotMasked(x, y, mask, xsize) 1
                                     
#define VOXEL(v,x,y,z) v[x + y*volume_xsize + z*volume_ysize*volume_xsize]

#define WEIGHT_INV(x) (1.0f/fabs(x))
#define WEIGHT_INV2(x) (1.0f/fabs(x*x))
#define WEIGHT_INV4(x) (1.0f/fabs(x*x*x*x))
#define WEIGHT_SUB(x) (1.0f - fabs(x))

// Gaussian weight function
#define WEIGHT_GAUSS_SIGMA (0.05f)

#define WEIGHT_GAUSS_SQRT_2PI 2.506628275f

#define WEIGHT_GAUSS_NONEXP_PART(sigma) (1.0f/(sigma*WEIGHT_GAUSS_SQRT_2PI))
#define WEIGHT_GAUSS_EXP_PART(dist, sigma) exp(-(dist*dist)/(2*sigma*sigma))

#define WEIGHT_GAUSS(x, sigma) (WEIGHT_GAUSS_NONEXP_PART(sigma)*WEIGHT_GAUSS_EXP_PART(x, sigma))

#define DW_WEIGHT(x) WEIGHT_INV(x)
#define VNN2_WEIGHT(x) WEIGHT_INV(x)

/**************/
/* End macros */
/**************/

/*****************/
/* Begin structs */
/*****************/

typedef struct _close_plane
{
	float dist;
	int plane_id;
} close_plane_t;

typedef struct _pixel
{
	unsigned char intensity;
	float dist;
} pixel_t;

/***************/
/* End structs */
/***************/

/********************/
/* Begin prototypes */
/********************/

// Declare all the functions, as Apple seems to need that


int isValidPixel(int x,
                 int y,
                 const __global unsigned char* mask,
                 int in_xsize,
                 int in_ysize);

#if PLANE_METHOD == PLANE_HEURISTIC
int
findHighestIdx(close_plane_t *planes,
               int n);
int
findClosestPlanes_heuristic(close_plane_t *close_planes,
                            __local float4* const plane_eqs,
                            __global float16* const plane_matrices,
                            const float4 voxel,
                            const float radius,
                            int* guess);
#endif

#if PLANE_METHOD == PLANE_EXACT
int
findClosestPlanes_exact(close_plane_t *close_planes,
                        __local float4* const plane_eqs,
                        __global float16* const plane_matrices,
                        const float4 voxel,
                        const float radius,
                        int* guess);

#endif

__global const unsigned char*
getImageData(int plane_id,
             __global const unsigned char* bscans_blocks[],
             int in_xsize,
             int in_ysize);

float4
transform(float16 matrix,
                 float4 voxel);

float4
transform_inv(float16 matrix,
                     float4 voxel);

float2
transform_inv_xy(float16 matrix, float4 voxel);

void
printMatrix(float16 matrix);

void
toImgCoord_int(int* x,
               int* y,
               float4 voxel,
               float16 plane_matrix,
               float in_xspacing,
               float in_yspacing);

void
toImgCoord_float(float* x,
                 float* y,
                 float4 voxel,
                 float16 plane_matrix,
                 float in_xspacing,
                 float in_yspacing);

float
bilinearInterpolation(float x,
                      float y,
                      const __global unsigned char* image,
                      int in_xsize);

pixel_t anisotropicFilter(const pixel_t *pixels,
                          int n_planes);

#if METHOD == METHOD_VNN
unsigned char
performInterpolation_vnn(close_plane_t *close_planes,
                         int n_close_planes,
                         __global const float16  *plane_matrices,
                         __local const float4 *plane_eqs,
                         __global const unsigned char* bscans_blocks[],
                         int in_xsize,
                         int in_ysize,
                         float in_xspacing,
                         float in_yspacing,
                         __global const unsigned char* mask,
                         float4 voxel);
#endif

#if METHOD == METHOD_VNN2
unsigned char
performInterpolation_vnn2(close_plane_t *close_planes,
                          int n_close_planes,
                          __global const float16  *plane_matrices,
                          __local const float4 *plane_eqs,
                          __global const unsigned char* bscans_blocks[],
                          int in_xsize,
                          int in_ysize,
                          float in_xspacing,
                          float in_yspacing,
                          __global const unsigned char* mask,
                          float4 voxel);
#endif

#if METHOD == METHOD_DW
unsigned char
performInterpolation_dw(close_plane_t *close_planes,
                        int n_close_planes,
                        __global const float16  *plane_matrices,
                        __local const float4 *plane_eqs,
                        __global const unsigned char* bscans_blocks[],
                        int in_xsize,
                        int in_ysize,
                        float in_xspacing,
                        float in_yspacing,
                        __global const unsigned char* mask,
                        float4 voxel);
#endif

#if METHOD == METHOD_ANISOTROPIC
unsigned char
performInterpolation_anisotropic(close_plane_t *close_planes,
                            int n_close_planes,
                            __global const float16  *plane_matrices,
                            __local const float4 *plane_eqs,
                            __global const unsigned char* bscans_blocks[],
                            int in_xsize,
                            int in_ysize,
                            float in_xspacing,
                            float in_yspacing,
                            __global const unsigned char* mask,
                            float4 voxel);
#endif

void
prepare_plane_eqs(__global float16 *plane_matrices,
                  __local float4 *plane_eqs);

__kernel void
voxel_methods(int volume_xsize,
              int volume_ysize,
              int volume_zsize,
              float volume_xspacing,
              float volume_yspacing,
              float volume_zspacing,
              int in_xsize,
              int in_ysize,
              float in_xspacing,
              float in_yspacing,
              // TODO: Wouldn't it be kind of nice if the bscans was an image sampler object?
              __global unsigned char* in_bscans_b0,
              __global unsigned char* in_bscans_b1,
              __global unsigned char* in_bscans_b2,
              __global unsigned char* in_bscans_b3,
              __global unsigned char* in_bscans_b4,
              __global unsigned char* in_bscans_b5,
              __global unsigned char* in_bscans_b6,
              __global unsigned char* in_bscans_b7,
              __global unsigned char* in_bscans_b8,
              __global unsigned char* in_bscans_b9,
              __global unsigned char* out_volume,
              __global float16 *plane_matrices,
              __global unsigned char* mask,
              __local float4 *plane_eqs,
              float radius);
	


/******************/
/* End prototypes */
/******************/



int isValidPixel(int x,
                 int y,
                 const __global unsigned char* mask,
                 int in_xsize,
                 int in_ysize)
{
#ifndef DEBUG
	return (isInside(x, in_xsize)
	        && isInside(y, in_ysize)
	        && isNotMasked(x, y, mask, in_xsize));
#else
	if((isInside(x, in_xsize)
	    && isInside(y, in_ysize)
	    && isNotMasked(x, y, mask, in_xsize)))
	{
		return 1;
	}
	else {
		DEBUG_PRINTF("Pixel %d, %d is not valid! Sizes: %d, %d\n",
		             x, y, in_xsize, in_ysize);
		return 0;
	}
#endif
 
}

#if PLANE_METHOD == PLANE_HEURISTIC
#define FIND_CLOSE_PLANES(a, b, c, d, e, f) findClosestPlanes_heuristic(a, b, c, d, e, f)

/**
 * Find the plane with the highest distance to the voxel
 * i.e. the plane with the highest absolute value of dist.
 * Return the index of that plane
 * @param *planes Pointer to first element of plane array
 * @param n size of array pointed to *planes
 */
int
findHighestIdx(close_plane_t *planes,
               int n)
{
	int maxidx = 0;
	float maxval = -1.0f;
	for(int i = 0; i < n; i++)
	{
		float abs = fabs(planes->dist);
		if(abs > maxval)
		{
			maxidx = i;
			maxval = abs;
		}
		planes++;
	}
	DEBUG_PRINTF("New maxidx: %d maxdist = %f\n", maxidx, maxval);
	return maxidx;
}
	


/**
 * Find planes that are within radius of voxel.
 * Search in both directions in the plane array, starting at guess
 * The assumption is that as you move away from the guess,
 * the distance to this voxel will increase. That assumption may not always be true, for instance
 * if the US probe was swept back and forth.
 * Finds the closest MAX_PLANES planes within radius,
 * provided no plane with distance greater than
 * 2x radius is found before any of the MAX_PLANES closest planes.
 */
int
findClosestPlanes_heuristic(close_plane_t *close_planes,
                            __local float4* const plane_eqs,
                            __global float16* const plane_matrices,
                            const float4 voxel,
                            const float radius,
                            int* guess)
{

	// Number of planes found so far
	int found = 0;
	
	// Done condition. .x  = up, .y = down
	int2 done = {0,0};
	
	// The index of the plane with the smallest distance found so far
	int smallest_idx = *guess;
	
	// The smallest distance found so far
	float smallest_dist = 99999.9f;
		
	// The index of the plane with the biggest index so far
	int max_idx = 0;

	// The biggest distance found so far
	float max_dist = radius;
	
	// If guess is 0, we will try to access data for plane id -1, which does not exist.
	// Assume plane 1 is close enough in that case
	if(*guess == 0) *guess = 1;

	// We won't be changing the guess, but the compiler wouldn't know that
	const int tmp_guess = *guess;

	
	for(int i = 0; !done.x || !done.y ; i++)
	{
		// Compute the indices of the planes we want to look at.
		int2 idx = {tmp_guess + i, tmp_guess - i - 1};

		// Compute the distances to those planes
		float2 dists = {dot(voxel, plane_eqs[idx.x]), dot(voxel, plane_eqs[idx.y])};

		// Compute the absolute distances to those planes
		float2 abs_dists = {fabs(dists.x), fabs(dists.y)}; // .x = abs_dist_up, .y = abs_dist_down,

		// Check if the plane is closer than the one farthest away we have included so far
		if(!done.x && abs_dists.x < max_dist)
		{
			// If yes, swap out the one with the longest distance for this plane
			close_planes[max_idx].dist = dists.x;
			close_planes[max_idx].plane_id = idx.x;
			found++;
			
			if(found >= MAX_PLANES)
			{
				// We have found MAX_PLANES planes, but we don't know they're the closest ones.
				// Find the next candidate for eviction -
				// the plane with the longest distance to the voxel
				max_idx = findHighestIdx(close_planes, MAX_PLANES);
				max_dist = fabs(close_planes[max_idx].dist);
			}
			else
			{
				// We have not yet found MAX_PLANES planes, so just keep filling the array
				max_idx++;
			}
			if(smallest_dist > abs_dists.x)
			{
				// Update next guess
				smallest_dist = abs_dists.x;
				smallest_idx = idx.x;
			}
		}

		// And the same in the down direction
		// Check if the plane is closer than the one farthest away we have included so far
		if(!done.y && abs_dists.y < max_dist)
		{
			// If yes, swap out the one with the longest distance for this plane
			close_planes[max_idx].dist = dists.y;
			close_planes[max_idx].plane_id = idx.y;
			found++;
			if(found >= MAX_PLANES)
			{
				// We have found MAX_PLANES planes, but we don't know they're the closest ones.
				// Find the next candidate for eviction -
				// the plane with the longest distance to the voxel
				max_idx = findHighestIdx(close_planes, MAX_PLANES);
				max_dist = fabs(close_planes[max_idx].dist);
			}
			else
			{
				// We have not yet found MAX_PLANES planes, so just keep filling the array
				max_idx++;
			}
			if(smallest_dist > abs_dists.y)
			{
				// Update next guess
				smallest_dist = abs_dists.y;
				smallest_idx = idx.y;
			}
		}


		// FIXME: The constant here represents a tradeoff between
		// guaranteeing to find all relevant planes, and performance (terminating earlier).
		// This should be investigate further.
		int2 term_dists = {abs_dists.x > 5.0f*radius, abs_dists.y > 5.0f*radius };

		int2 term_boundaries = {idx.x == N_PLANES-1, idx.y == 0};
				
		done = done + term_dists + term_boundaries;
			
	} 

	// Update next guess
	*guess = smallest_idx;
	
	return min(found, MAX_PLANES);
}
#endif

#if PLANE_METHOD == PLANE_CLOSEST
#define FIND_CLOSE_PLANES(a, b, c, d, e, f) findClosestPlanes_exact(a, b, c, d, e, f)
/**
 * Find the closest planes to the voxel.
 * This method, unlike the heuristic method,
 * guarantees that the closest planes are found, provided that there are no more than
 * MAX_PLANES_WITHIN_RADIUS planes within the radius
 * However, it is slower, because it has to check all the planes.
 * It works by first finding MAX_PLANES_WITHIN_RADIUS planes closer than radius,
 * and then picking the best MAX_PLANES planes by a variant of selection sort
 */
int findClosestPlanes_exact(close_plane_t *close_planes_ret,
                      __local float4* const plane_eqs,
                      __global float16* const plane_matrices,
                      const float4 voxel,
                      const float radius,
                      int *guess)
{

	// How many planes closer than radius we have found so far
	int found = 0;

	// Assume MAX_PLANES_WITHIN_RADIUS is huge, so we have room for them all
	// Address pointed to by orig_ptr never changes
	close_plane_t orig_ptr[MAX_PLANES_WITHIN_RADIUS];

	// But the address of this pointer changes!
	close_plane_t *close_planes = orig_ptr;

	// Find all planes (up to MAX_PLANES_WITHIN_RADIUS) closer than radius
	float dist, abs_dist;
	for(int i = 0; i < N_PLANES && found < MAX_PLANES_WITHIN_RADIUS; i++)
	{
		dist = dot(plane_eqs[i], voxel);
		abs_dist = fabs(dist);
		if(abs_dist < radius)
		{
			found++;
			close_planes->plane_id = i;
			close_planes->dist = dist;
			close_planes++;
		}
	}
	close_planes = orig_ptr;
	
	// Now pick the best MAX_PLANES and put them in close_planes_ret

	int done = 0;
	for(int i = 0; i < MAX_PLANES && !done; i++)
	{
		float smallest_dist = 99999.0f;
		int smallest_idx = -1;
		for(int j = 0; j < found; j++)
		{
			if(fabs(close_planes[j].dist) < smallest_dist)
			{
				smallest_dist = fabs(close_planes[j].dist);
				smallest_idx = j;
			}
		}
		if(smallest_idx == -1)
		{
			done = 1;
			break;
		}
		close_planes_ret[i] = close_planes[smallest_idx];
		// Bigger than initial smallest_dist
		close_planes[smallest_idx].dist = 999999.0f;
	}
	return min(MAX_PLANES, found);
}
#endif

/**
 * Get a pointer to the first pixel of the image frame given by plane_id
 */
__global const unsigned char*
getImageData(int plane_id,
             __global const unsigned char* bscans_blocks[],
             int in_xsize,
             int in_ysize)
{
	int scans_per_block = N_PLANES / N_BLOCKS;
	int n_big_blocks = N_PLANES % N_BLOCKS;
	int block, idx_in_block;
	// Check if plane is in one of the big blocks
	if(plane_id < n_big_blocks * (scans_per_block+1))
	{
		// It's in a big block
		block = plane_id / (scans_per_block+1);
		idx_in_block = plane_id % (scans_per_block+1);
	}
	else
	{
		// It's in a small block
		int index_into_small_blocks = plane_id - (n_big_blocks * (scans_per_block+1));
		idx_in_block = index_into_small_blocks % scans_per_block;
		block = n_big_blocks + (index_into_small_blocks / scans_per_block);
	}
	return &bscans_blocks[block][idx_in_block*in_xsize*in_ysize];
}

/**
 * Perform a standard forward transformation of voxel - eqvivalent to multiplying matrix with voxel
 */
float4
transform(float16 matrix,
          float4 voxel)
{
	float4 ret;
	
	ret.x = matrix.s0*voxel.x + matrix.s1*voxel.y + matrix.s2*voxel.z + matrix.s3;
	ret.y = matrix.s4*voxel.x + matrix.s5*voxel.y + matrix.s6*voxel.z + matrix.s7;
	ret.z = matrix.s8*voxel.x + matrix.s9*voxel.y + matrix.sA*voxel.z + matrix.sB;
	
	ret.w = 1.0f;
	return ret;

}

/**
 * Perform an inverse transformation of voxel - eqvivalent to multiplying the inverse of the matrix with voxel
 */
float4 transform_inv(float16 matrix,
                     float4 voxel)
{
	float4 ret;
	float4 col0 = matrix.s048C;
	float4 col1 = matrix.s159D;
	float4 col2 = matrix.s26AE;
	float4 col3 = matrix.s37BF;
	
	ret.x = dot(voxel,col0) - dot(col3,col0);
	ret.y = dot(voxel,col1) - dot(col3,col1);
	ret.z = dot(voxel,col2) - dot(col3,col2);
	ret.w = 1.0f;
	return ret;
}

/**
 * Perform an inverse transformation of voxel, as in transform_inv, but only transform the x and y coordinates. This is useful
 * when finding image coordinates.
 */
float2 transform_inv_xy(float16 matrix, float4 voxel)
{
	float2 ret;
	float4 col0 = matrix.s048C;
	float4 col1 = matrix.s159D;
	float4 col3 = matrix.s37BF;

	ret.x = dot(voxel,col0) - dot(col3,col0);
	ret.y = dot(voxel,col1) - dot(col3,col1);
	return ret;
}

/**
 * Print a matrix - useful for debugging
 */
void printMatrix(float16 matrix)
{
	printf("[ %f, %f, %f, %f\n   %f, %f, %f, %f\n   %f, %f, %f, %f\n   %f, %f, %f, %f\n",
	       matrix.s0,
	       matrix.s1,
	       matrix.s2,
	       matrix.s3,
	       matrix.s4,
	       matrix.s5,
	       matrix.s6,
	       matrix.s7,
	       matrix.s8,
	       matrix.s9,
	       matrix.sA,
	       matrix.sB,
	       matrix.sC,
	       matrix.sD,
	       matrix.sE,
	       matrix.sF);
}

/**
 * Transform to integer image coordinates - i.e. pixel coordinates
 */
void toImgCoord_int(int* x,
                    int* y,
                    float4 voxel,
                    float16 plane_matrix,
                    float in_xspacing,
                    float in_yspacing)
{

	float2 transformed_voxel = transform_inv_xy(plane_matrix, voxel);

	*x = ((transformed_voxel.x/in_xspacing) + 0.5f);
	*y = ((transformed_voxel.y/in_yspacing) + 0.5f);
}

/**
 * Transform to floating point image coordinates
 */
void toImgCoord_float(float* x,
                float* y,
                float4 voxel,
                float16 plane_matrix,
                float in_xspacing,
                float in_yspacing)
{

	float2 transformed_voxel = transform_inv_xy(plane_matrix, voxel);

	*x = ((transformed_voxel.x/in_xspacing));
	*y = ((transformed_voxel.y/in_yspacing));
}


/**
 * Perform bilinear interpolation to retrieve an interpolated pixel value from an image.
 */
float bilinearInterpolation(float x,
                            float y,
                            const __global unsigned char* image,
                            int in_xsize)
{

	// SOURCE: https://en.wikipedia.org/w/index.php?title=Bilinear_interpolation&oldid=574742881 (need better source for report)
	
	int2 pos = {x, y};
	float2 offset = {x - pos.x, y - pos.y};

	float4 values = { image[pos.x + pos.y*in_xsize],        // Lower left
	                  image[pos.x+1 + pos.y*in_xsize],      // Lower right
	                  image[pos.x + 1 + (pos.y+1)*in_xsize],// Upper right
	                  image[pos.x + (pos.y+1)*in_xsize] };  // Upper left

	float4 weights = { (1.0f - offset.x)*(1.0f - offset.y), // Lower left
	                   (offset.x)*(1.0f - offset.y),        // Lower right
	                   (offset.x)*(offset.y),               // Upper right
	                   (1.0f - offset.x)*(offset.y) };      // Upper left

	return dot(values, weights);
	
}



#if METHOD == METHOD_VNN
#define PERFORM_INTERPOLATION(a, b, c, d, e, f, g, h, i , j, k)	  \
	performInterpolation_vnn(a, b, c, d, e, f, g, h, i, j, k)

/**
 * Perform interpolation using the Voxel Nearest Neighbour method.
 * This works by taking finding the plane closest to the voxel,
 * projecting the voxel orthogonally onto the image plane to find pixel coordinates
 * and taking the pixel value
 */
unsigned char
performInterpolation_vnn(close_plane_t *close_planes,
                         int n_close_planes,
                         __global const float16  *plane_matrices,
                         __local const float4 *plane_eqs,
                         __global const unsigned char* bscans_blocks[],
                         int in_xsize,
                         int in_ysize,
                         float in_xspacing,
                         float in_yspacing,
                         __global const unsigned char* mask,
                         float4 voxel)
{
	if(n_close_planes == 0) return 1;
	
	int plane_id = 0;
	float lowest_dist = 10.0f;
	int close_plane_id = 0;

	// Find the closest plane
	for(int i = 0; i < n_close_planes;  i++)
	{
		float fabs_dist = fabs(close_planes[i].dist);
		if(fabs_dist < lowest_dist)
		{
			lowest_dist = fabs_dist;
			plane_id = close_planes[i].plane_id;
			close_plane_id = i;
		}
	} 
			
	const __global unsigned char* image = getImageData(plane_id,
	                                                   bscans_blocks,
	                                                   in_xsize,
	                                                   in_ysize); 

	// Now we project the voxel onto the plane by translating the voxel along the
	// normal vector of the plane.
	float4 translated_voxel = projectOntoPlane(voxel,
	                                           plane_matrices[plane_id],
	                                           close_planes[close_plane_id].dist);
	translated_voxel.w = 1.0f;

	
	// And then we get the pixel space coordinates
	int x, y;
	toImgCoord_int(&x,
	               &y,
	               translated_voxel,
	               plane_matrices[plane_id],
	               in_xspacing,
	               in_yspacing);

	if(!isValidPixel(x,y, mask, in_xsize, in_ysize))
	{
		return 1;
	}

	return max((unsigned char)1, image[y*in_xsize + x]);

}
#endif


pixel_t anisotropicFilter(const pixel_t *pixels,
                          int n_planes)
{
	// Calculate the variance

	float mean_value = 0.0f;
	for(int i = 0; i < n_planes; i++)
	{
		mean_value += pixels[i].intensity;
	}
	mean_value = mean_value / n_planes;

	float variance = 0.0f;
	for(int i = 0; i < n_planes; i++)
	{
		float tmp = pixels[i].intensity - mean_value;
		variance += tmp*tmp;
	}
	variance = variance / n_planes;

	// We want high variance regions to have a sharp weight function
	// and small variance regions to have a smooth weight function.

	if(variance < 0.1f) variance = 0.1f;
	float gauss_sigma = 10.0f / sqrt(variance);

	if(gauss_sigma < 0.1f) gauss_sigma = 0.1f;
	if(variance > 0.1f && mean_value> 10.0f)
		DEBUG_PRINTF("Mean: %f, variance: %f, sigma: %f\n", mean_value, variance, gauss_sigma);


	float sum_weights = 0.0f;
	float sum = 0.0f;
	// Use the resulting gauss sigma to calcualte weights
	for(int i = 0; i < n_planes; i++)
	{
		float weight = WEIGHT_GAUSS(pixels[i].dist, gauss_sigma);
		sum += pixels[i].intensity*weight;
		sum_weights += weight;
	}

	pixel_t ret;
	ret.dist = 0.0f;
	ret.intensity = sum / sum_weights;
	return ret;
}


#if METHOD == METHOD_VNN2
#define PERFORM_INTERPOLATION(a, b, c, d, e, f, g, h, i ,j, k)	  \
	performInterpolation_vnn2(a, b, c, d, e, f, g, h, i, j, k)

/**
 * Perform interpolation using the VNN2 method. For each close plane, add (1/dist)*closest_pixel_value to the sum.
 * In the end, divide sum by sum(1/dist), and you have your voxel value.
 */
unsigned char
performInterpolation_vnn2(close_plane_t *close_planes,
                          int n_close_planes,
                          __global const float16  *plane_matrices,
                          __local const float4 *plane_eqs,
                          __global const unsigned char* bscans_blocks[],
                          int in_xsize,
                          int in_ysize,
                          float in_xspacing,
                          float in_yspacing,
                          __global const unsigned char* mask,
                          float4 voxel)
{
	if(n_close_planes == 0) return 1;
	
	
	float scale = 0.0f;
	
	float val = 0;
	for(int i = 0; i < n_close_planes; i++)
	{

		int plane_id = close_planes[i].plane_id;
		const __global unsigned char* image = getImageData(close_planes[i].plane_id,
		                                             bscans_blocks,
		                                             in_xsize,
		                                             in_ysize);


		// Now we project the voxel onto the plane by translating the voxel along the
		// normal vector of the plane.
		voxel.w = 1.0f;
		float4 translated_voxel = projectOntoPlaneEq(voxel,
		                                             plane_eqs[plane_id],
		                                             close_planes[i].dist);
	
		translated_voxel.w = 1.0f;
		// And then we get the pixel space coordinates
		int x, y;
		toImgCoord_int(&x,
		               &y,
		               translated_voxel,
		               plane_matrices[plane_id],
		               in_xspacing,
		               in_yspacing);
		
		if(!isValidPixel(x,y, mask, in_xsize, in_ysize))
		{
			continue;
		}
		float dist = fabs(close_planes[i].dist);
		
		if(dist < 0.001f)
			dist = 0.001f;
		float weight = VNN2_WEIGHT(dist);
		
		scale += weight;
		val += (image[y*in_xsize + x] * weight);
	}		

	
	return max((unsigned char)1, (unsigned char) (val / scale));
	
}
#endif

#if METHOD == METHOD_DW
#define PERFORM_INTERPOLATION(a, b, c, d, e, f, g, h, i ,j, k)	  \
	performInterpolation_dw(a, b, c, d, e, f, g, h, i, j, k)

/**
 * Perform interpolation using the DW method. Works the same as VNN2, but instead of taking the closest pixel on each image plane,
 * the value from each plane is a bilinearly interpolated from that plane.
 */
unsigned char
performInterpolation_dw(close_plane_t *close_planes,
                        int n_close_planes,
                        __global const float16  *plane_matrices,
                        __local const float4 *plane_eqs,
                        __global const unsigned char* bscans_blocks[],
                        int in_xsize,
                        int in_ysize,
                        float in_xspacing,
                        float in_yspacing,
                        __global const unsigned char* mask,
                        float4 voxel)
{
                                      

	if(n_close_planes == 0) return 1;
	

	float scale = 0.0f;
	
	float val = 0;
	for(int i = 0; i < n_close_planes; i++)
	{

		int plane_id = close_planes[i].plane_id;
		const __global unsigned char* image = getImageData(close_planes[i].plane_id,
		                                             bscans_blocks,
		                                             in_xsize,
		                                                   in_ysize);


		// Now we project the voxel onto the plane by translating the voxel along the
		// normal vector of the plane.
		voxel.w = 1.0f;
		float4 translated_voxel = projectOntoPlaneEq(voxel,
		                                             plane_eqs[plane_id],
		                                             close_planes[i].dist);
	
		translated_voxel.w = 1.0f;
		// And then we get the pixel space coordinates
		float x, y;
		toImgCoord_float(&x,
		           &y,
		           translated_voxel,
		           plane_matrices[plane_id],
		           in_xspacing,
		           in_yspacing);


		int ix, iy;
		ix = x;
		iy = y;
		if(!isValidPixel(ix,iy, mask, in_xsize, in_ysize) 
		   || !isValidPixel(ix+1, iy, mask, in_xsize, in_ysize)
		   || !isValidPixel(ix+1, iy+1, mask, in_xsize, in_ysize)
		   || !isValidPixel(ix, iy+1, mask, in_xsize, in_ysize)
			)
		{
			continue;
		}
		
		float interpolated_value = bilinearInterpolation(x, y, image, in_xsize);
			
		float dist = fabs(close_planes[i].dist);
		if(dist < 0.001f) dist = 0.001f;
		float weight = DW_WEIGHT(dist);
		scale += weight;
		val += (interpolated_value * weight);
	}		

	
	return max((unsigned char)1, (unsigned char) (val / scale));
	
}
#endif

#if METHOD == METHOD_ANISOTROPIC
#define PERFORM_INTERPOLATION(a, b, c, d, e, f, g, h, i ,j, k)	  \
	performInterpolation_anisotropic(a, b, c, d, e, f, g, h, i, j, k)

void siftDown(pixel_t *pixels,
              int start,
              int end)
{
	int root = start;
	int swap;
	int child;
	pixel_t tmp;
#define swap(a, b) tmp = a; a = b; b = tmp
	while(root*2 + 1 <= end)
	{
		child = root*2+1;
		swap = root;
		if(pixels[swap].intensity < pixels[child].intensity)
		{
			swap = child;
		}
		if(child+1 <= end && pixels[swap].intensity < pixels[child+1].intensity)
		{
			swap = child+1;
		}
		if(swap != root)
		{
			swap(pixels[root], pixels[swap]);
			root = swap;
		}
		else
		{
			return;
		}
	}
}
	
void heapify(pixel_t *pixels,
             int n)
{
	int start = (n - 2) / 2;

	while(start >= 0)
	{
		siftDown(pixels, start, n - 1);
		start--;
	}
}
	

// Implement heapsort
void sort(pixel_t *pixels,
          int n)
{
	pixel_t tmp;
#define swap(a, b) tmp = a; a = b; b = tmp
	heapify(pixels, n);
	int end = n-1;
	while(end > 0)
	{
		swap(pixels[end], pixels[0]);
		end--;
		siftDown(pixels, 0, end);
	}
}

#define WEIGHT_FUNCTION(x) (1.0f - fabs(x.dist))
// Find the weighted median of an unsorted array of pixels
pixel_t weighted_median(pixel_t *pixels,
                        int n_pixels)
{
	// Sort the pixels
	sort(pixels, n_pixels);
	// Compute the sum of the weights
	float sum_weight = 0.0f;
	for(int i = 0; i < n_pixels; i++)
	{
		sum_weight += WEIGHT_FUNCTION(pixels[i]);
	}
	// Find the first index for which sum is greater than sum_weight/2
	const float sum_weight_half = sum_weight / 2;
	float sum = 0.0f;
	int idx = 0;
	for(idx = 0; idx < n_pixels; idx++)
	{
		sum += WEIGHT_FUNCTION(pixels[idx]);
		if(sum >= sum_weight_half)
		{
			break;
		}
	}
	return pixels[idx];
	
}

/**
 * Perform interpolation using an anisotropic filter
 */
unsigned char
performInterpolation_anisotropic(close_plane_t *close_planes,
                            int n_close_planes,
                            __global const float16  *plane_matrices,
                            __local const float4 *plane_eqs,
                            __global const unsigned char* bscans_blocks[],
                            int in_xsize,
                            int in_ysize,
                            float in_xspacing,
                            float in_yspacing,
                            __global const unsigned char* mask,
                            float4 voxel)
{
	// First, find all the relevant pixels
#if ANISOTROPIC_METHOD == ANISOTROPIC_METHOD_INCLUDE_ALL
	pixel_t pixels[MAX_PLANES*ANISOTROPIC_SIZE*ANISOTROPIC_SIZE];
#elif ANISOTROPIC_METHOD == ANISOTROPIC_METHOD_BILINEAR_ON_PLANE
	pixel_t pixels[MAX_PLANES];
#elif ANISOTROPIC_METHOD == ANISOTROPIC_METHOD_GAUSSIAN_ON_PLANE
	pixel_t pixels[MAX_PLANES*ANISOTROPIC_GAUSSIAN_SIZE*ANISOTROPIC_GAUSSIAN_SIZE];
#endif

	
	int pos = 0;
	for(int i = 0; i < n_close_planes; i++)
	{
		const int plane_id = close_planes[i].plane_id;
		const __global unsigned char* image = getImageData(plane_id,
		                                             bscans_blocks,
		                                             in_xsize,
		                                             in_ysize);

		// Project onto plane
		voxel.w = 1.0f;
		float4 translated_voxel = projectOntoPlaneEq(voxel,
		                                             plane_eqs[plane_id],
		                                             close_planes[i].dist);
		translated_voxel.w = 1.0f;


#if ANISOTROPIC_METHOD == ANISOTROPIC_METHOD_INCLUDE_ALL
		
		int x, y;
		toImgCoord_int(&x,
		               &y,
		               translated_voxel,
		               plane_matrices[plane_id],
		               in_xspacing,
		               in_yspacing);
		for(int j = -ANISOTROPIC_SIZE/2; j <= ANISOTROPIC_SIZE/2; j++)
		{
			for(int k = -ANISOTROPIC_SIZE/2; k <= ANISOTROPIC_SIZE/2; k++)
			{
				int _x = x + j;
				int _y = y + k;
				if(!isValidPixel(_x, _y, mask, in_xsize, in_ysize))
				{
					continue;
				}
				pixels[pos].intensity = image[_y*in_xsize + _x];


				// We know the distance in the direction normal to the plane.
				// Since this is a pixel _on_ the plane, pretend the distance along the
				// normal is one cathete, and the distance on the image plane is another catethe.
				// The distance is then the hypotenuse.

				float dist_x = j*in_xspacing;
				float dist_y = k*in_yspacing;
				float sq_x = dist_x*dist_x;
				float sq_y = dist_y*dist_y;

				float along_plane_dist = sqrt(sq_x + sq_y);
				pixels[pos].dist = sqrt(close_planes[i].dist*close_planes[i].dist + sq_x + sq_y);
				pos++;
			}
		}
		
#elif ANISOTROPIC_METHOD == ANISOTROPIC_METHOD_BILINEAR_ON_PLANE
		float x, y;
		toImgCoord_float(&x,
		                 &y,
		                 translated_voxel,
		                 plane_matrices[plane_id],
		                 in_xspacing,
		                 in_yspacing);

		
		int ix, iy;
		ix = x;
		iy = y;
		if(!isValidPixel(ix,iy, mask, in_xsize, in_ysize) 
		   || !isValidPixel(ix+1, iy, mask, in_xsize, in_ysize)
		   || !isValidPixel(ix+1, iy+1, mask, in_xsize, in_ysize)
		   || !isValidPixel(ix, iy+1, mask, in_xsize, in_ysize)
				)
			{
			continue;
		}
		pixels[pos].intensity = bilinearInterpolation(x,
		                                              y,
		                                              image,
		                                              in_xsize);
		pixels[pos++].dist = close_planes[i].dist;

#elif ANISOTROPIC_METHOD == ANISOTROPIC_METHOD_GAUSSIAN_ON_PLANE
		int x, y;
		toImgCoord_int(&x,
		               &y,
		               translated_voxel,
		               plane_matrices[plane_id],
		               in_xspacing,
		               in_yspacing);
		float gauss_weight_sum = 0.0f;
		float gauss_value = 0.0f;
		for(int ix = 0; ix < ANISOTROPIC_GAUSSIAN_SIZE; ix++)
		{
			for(int iy = 0; iy < ANISOTROPIC_GAUSSIAN_SIZE; iy++)
			{
				int xpos = x + ix - ANISOTROPIC_GAUSSIAN_SIZE/2;
				int ypos = y + iy - ANISOTROPIC_GAUSSIAN_SIZE/2;
				int xmaskpos = xpos - x;
				int ymaskpos = ypos - y;
				if(!isValidPixel(xpos, ypos, mask, in_xsize, in_ysize))
				{
					// If the pixel is invalid, we simply ignore that pixel
					continue;
				}

				float weight = WEIGHT_GAUSS(sqrt((float)(xmaskpos*xmaskpos + ymaskpos*ymaskpos)), 0.5f);
				gauss_value += weight * image[xpos + ypos*in_xsize];
				gauss_weight_sum += weight;
			}
		}
		pixels[pos].intensity = gauss_value / gauss_weight_sum;
		pixels[pos++].dist = close_planes[i].dist;
#endif
		
	}

	
	if(pos == 0)
	{
		return 1;
	}
	
	//return max((unsigned char)1, weighted_median(pixels, pos).intensity);
	return max((unsigned char)1, anisotropicFilter(pixels, pos).intensity);

}

#endif
/**
 * Build the plane equations from the matrices and store them in local memory
 */
void
prepare_plane_eqs(__global float16 *plane_matrices,
                 __local float4 *plane_eqs)
{
	int id = get_local_id(0);
	int max_local_id = get_local_size(0);
	const int n_planes_pr_thread = (N_PLANES / max_local_id) + 1;

	for(int i = 0; i < n_planes_pr_thread; i++)
	{
		int idx = i + n_planes_pr_thread * id;
		if(idx >= N_PLANES) break;
		plane_eqs[idx].xyz = plane_matrices[idx].s26A;
		plane_eqs[idx].w = -dot(plane_matrices[idx].s26AE, plane_matrices[idx].s37BF);
	}
	barrier(CLK_LOCAL_MEM_FENCE);
}
                 

/** The entry point for this set of reconstruction methods.
 * Parameters:
 * @param volume_xsize Size of output volume, X direction
 * @param volume_ysize Size of output volume, Y direction
 * @param volume_zsize Size of output volume, Z direction
 * @param volume_xspacing Voxel size of output volume, X direction
 * @param volume_yspacing Voxel size of output volume, Y direction
 * @param volume_zspacing Voxel size of output volume, Z direction
 * @param in_xsize Size of each ultrasound input image in pixels, X direction
 * @param in_ysize Size of each ultrasound input image in pixels, Y direction
 * @param in_xspacing Size of each pixel in input ultrasound images, X direction
 * @param in_yspacing Size of each pixel in input ultrasound images, Y direction
 * @param in_bscans_b_ Ultrasound input images
 * @param out_volume Output volume - reconstructed volume goes here
 * @param plane_matrices One matrix per image plane specifying the transform from pixel space to voxel space
 * @param plane_eqs Pointer to local memory where we will store plane equations
 * @param radius The radius of the kernel - how far away to accept voxels from.
 */
__kernel void
voxel_methods(int volume_xsize,
              int volume_ysize,
              int volume_zsize,
              float volume_xspacing,
              float volume_yspacing,
              float volume_zspacing,
              int in_xsize,
              int in_ysize,
              float in_xspacing,
              float in_yspacing,
              // TODO: Wouldn't it be kind of nice if the bscans was an image sampler object?
              __global unsigned char* in_bscans_b0,
              __global unsigned char* in_bscans_b1,
              __global unsigned char* in_bscans_b2,
              __global unsigned char* in_bscans_b3,
              __global unsigned char* in_bscans_b4,
              __global unsigned char* in_bscans_b5,
              __global unsigned char* in_bscans_b6,
              __global unsigned char* in_bscans_b7,
              __global unsigned char* in_bscans_b8,
              __global unsigned char* in_bscans_b9,
              __global unsigned char* out_volume,
              __global float16 *plane_matrices,
              __global unsigned char *mask,
              __local float4 *plane_eqs,
              float radius  
	)
{

	int id = get_global_id(0);
	int x = id % volume_xsize;
	int z = id / volume_xsize;

	// Aggregate pointers to the bscan blocks into one array for convenience
	
	const __global unsigned char *bscans_blocks[] = { in_bscans_b0,
	                                            in_bscans_b1,
	                                            in_bscans_b2,
	                                            in_bscans_b3,
	                                            in_bscans_b4,
	                                            in_bscans_b5,
	                                            in_bscans_b6,
	                                            in_bscans_b7,
	                                            in_bscans_b8,
	                                            in_bscans_b9 };
	                             
		
	// For most of these algorithms we need to find some set of close planes.
	// We find all planes that are inside the voxel radius
	close_plane_t close_planes[MAX_PLANES+1];
	int n_close_planes;
	int guess = 0;
	float4 voxel = {x * volume_xspacing,
	                0.0f,
	                z * volume_zspacing,
	                1.0f};
	// Find the plane closest to the initial voxel
	float smallest_dist = 99999999.9f;
	float dist;
	
	prepare_plane_eqs(plane_matrices, plane_eqs);
	

	
	// Return if x/z is invalid
	
	if(z >= volume_zsize) return;
	if(x >= volume_xsize) return;
	
	
	for(int i = 0; i < N_PLANES; i++)
	{
		dist = fabs(dot(voxel,plane_eqs[i]));
		//dist = fabs(plane_dist(voxel,plane_matrices[i]));
		if(dist < smallest_dist)
		{
			smallest_dist = dist;
			guess = i;
		}
	} 


	
	// Iterate over Y axis
	for(int y = 0; y < volume_ysize; y++)
	{
		voxel.y = y*volume_yspacing;
		
		// Find all planes closer than radius

		n_close_planes = FIND_CLOSE_PLANES(close_planes,
		                                   plane_eqs,
		                                   plane_matrices,
		                                   voxel,
		                                   radius,
		                                   &guess);
		


		// Call appropriate method to determine pixel value
		VOXEL(out_volume,x,y,z) = PERFORM_INTERPOLATION(close_planes,
		                                                n_close_planes,
		                                                plane_matrices,
		                                                plane_eqs,
		                                                bscans_blocks,
		                                                in_xsize,
		                                                in_ysize,
		                                                in_xspacing,
		                                                in_yspacing,
		                                                mask,
		                                                voxel);
		
		//VOXEL(out_volume, x, y, z) = x;
		//VOXEL(out_volume, x, y, z) = ((float)z/(float)volume_zsize) * 255;
		//VOXEL(out_volume, x,y,z) = 1;
			
	}
}
	
