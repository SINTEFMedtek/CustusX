

// At current, this is a temporary playground file for Tord

/*******************/
/* Begin constants */
/*******************/



#define N_BLOCKS 10

// Reconstruction methods
#define METHOD_VNN 0
#define METHOD_VNN2 1
#define METHOD_DW 2
#define METHOD_ANISOTROPIC 3

// Plane searching methods
#define PLANE_HEURISTIC 0
#define PLANE_CLOSEST 1


// Anisotropic method specific constants
#define ANISOTROPIC_SIZE 3
#define ANISOTROPIC_GAUSSIAN_SIZE 3

#define ANISOTROPIC_METHOD_INCLUDE_ALL 0
#define ANISOTROPIC_METHOD_BILINEAR_ON_PLANE 1
#define ANISOTROPIC_METHOD_GAUSSIAN_ON_PLANE 2


#define ANISOTROPIC_METHOD ANISOTROPIC_METHOD_BILINEAR_ON_PLANE

// Local search related parameters
#define LOCAL_SEARCH_DISTANCE 10
#undef MAX_MULTISTART_STARTS
#define MAX_MULTISTART_STARTS 5
/*****************/
/* End constants */
/*****************/


/****************/
/* Begin macros */
/****************/

//#define DEBUG
//#define CHECK_PLANE_INDICES

#ifdef DEBUG
#define DEBUG_PRINTF(...) if((get_global_id(0) % 5000) == 0) printf(##__VA_ARGS__)
//#define DEBUG_PRINTF(...) printf(##__VA_ARGS__)
#define BOUNDS_CHECK(x, min, max) if(x < min || x >= max) printf("Line %d: %s out of range: %d min: %d max: %d\n", __LINE__, #x, x, min, max)
#else
#define DEBUG_PRINTF(...)
#define BOUNDS_CHECK(x, min, max)
#endif


#define plane_dist(voxel, matrix) (dot(matrix.s26AE,voxel) - dot(matrix.s26AE, matrix.s37BF))

#define projectOntoPlane(voxel, matrix, dist) (voxel - dist*(matrix.s26AE))

#define projectOntoPlaneEq(voxel, eq, dist) (voxel - dist*(eq))

#define isInside(x, size) ((x) >= 0 && (x) < (size))
//#define isNotMasked(x, y, mask, xsize) ((mask)[(x) + (y)*(xsize)] > 0)
#define isNotMasked(x, y, mask, xsize) 1

#define VOXEL(v,x,y,z) v[x + y*volume_xsize + z*volume_ysize*volume_xsize]

#define WEIGHT_INV(x) (1.0f/fabs(x))
#define WEIGHT_INV2(x) (1.0f/fabs(x*x))
#define WEIGHT_INV4(x) (1.0f/fabs(x*x*x*x))
#define WEIGHT_SUB(x) (1.0f - fabs(x))

// Gaussian weight function
#define WEIGHT_GAUSS_SIGMA (0.05f)

#define WEIGHT_GAUSS_SQRT_2PI 2.506628275f

#define WEIGHT_GAUSS_NONEXP_PART(sigma) (1.0f/(sigma*WEIGHT_GAUSS_SQRT_2PI))
#define WEIGHT_GAUSS_EXP_PART(dist, sigma) exp(-(dist*dist)/(2*sigma*sigma))

#define WEIGHT_GAUSS(x, sigma) (WEIGHT_GAUSS_NONEXP_PART(sigma)*WEIGHT_GAUSS_EXP_PART(x, sigma))

#define DW_WEIGHT(x) WEIGHT_INV(x)
#define VNN2_WEIGHT(x) WEIGHT_INV(x)

#define CLOSE_PLANE_IDX(p, i) p[get_local_id(0)*(MAX_PLANES+1)+(i)]

/**************/
/* End macros */
/**************/

/*****************/
/* Begin structs */
/*****************/

typedef struct _close_plane
{
	float dist;
	int plane_id;
} close_plane_t;

typedef struct _pixel
{
	unsigned char intensity;
	float dist;
} pixel_t;

/***************/
/* End structs */
/***************/

/********************/
/* Begin prototypes */
/********************/

// Declare all the functions, as Apple seems to need that


int isValidPixel(int x,
                 int y,
                 const __global unsigned char* mask,
                 int in_xsize,
                 int in_ysize);

int
findHighestIdx(__local close_plane_t *planes,
               int n);
int2
findClosestPlanes_heuristic(__local close_plane_t *close_planes,
                            __local float4* const plane_eqs,
                            __global float16* const plane_matrices,
                            const float4 voxel,
                            const float radius,
                            int guess,
                            bool doTermDistance,
                            __global const unsigned char* mask,
                            int in_xsize,
                            int in_ysize,
                            float in_xspacing,
                            float in_yspacing);

int2
findClosestPlanes_multistart(__local close_plane_t *close_planes,
                             __local float4* const plane_eqs,
                             __global float16* const plane_matrices,
                             const float4 voxel,
                             const float radius,
                             int *multistart_guesses,
                             int n_multistart_guesses,
                             bool doTermDistance,
                             __global const unsigned char* mask,
                             int in_xsize,
                             int in_ysize,
                             float in_xspacing,
                             float in_yspacing);

#if PLANE_METHOD == PLANE_EXACT
#define FIND_CLOSE_PLANES(a, b, c, d, e, f, g, h, i, j, k, l) findClosestPlanes_multistart(a, b, c, d, e, f, 1, g, h, i, j, k, l)
#elif PLANE_METHOD == PLANE_CLOSEST

#ifdef MAX_MULTISTART_STARTS
#undef MAX_MULTISTART_STARTS
#define MAX_MULTISTART_STARTS 1
#endif

#define FIND_CLOSE_PLANES(a, b, c, d, e, f, g, h, i, j, k, l) findClosestPlanes_multistart(a, b, c, d, e, f, 0, g, h, i, j, k, l)
#endif

__global const unsigned char*
getImageData(int plane_id,
             __global const unsigned char* bscans_blocks[],
             int in_xsize,
             int in_ysize);

float4
transform(float16 matrix,
                 float4 voxel);

float4
transform_inv(float16 matrix,
                     float4 voxel);

float2
transform_inv_xy(float16 matrix, float4 voxel);

void
printMatrix(float16 matrix);

void
toImgCoord_int(int* x,
               int* y,
               float4 voxel,
               float16 plane_matrix,
               float in_xspacing,
               float in_yspacing);

void
toImgCoord_float(float* x,
                 float* y,
                 float4 voxel,
                 float16 plane_matrix,
                 float in_xspacing,
                 float in_yspacing);

float
bilinearInterpolation(float x,
                      float y,
                      const __global unsigned char* image,
                      int in_xsize);

pixel_t anisotropicFilter(const pixel_t *pixels,
                          int n_planes);

#if METHOD == METHOD_VNN
unsigned char
performInterpolation_vnn(__local close_plane_t *close_planes,
                         int n_close_planes,
                         __global const float16  *plane_matrices,
                         __local const float4 *plane_eqs,
                         __global const unsigned char* bscans_blocks[],
                         int in_xsize,
                         int in_ysize,
                         float in_xspacing,
                         float in_yspacing,
                         __global const unsigned char* mask,
                         float4 voxel);
#endif

#if METHOD == METHOD_VNN2
unsigned char
performInterpolation_vnn2(__local close_plane_t *close_planes,
                          int n_close_planes,
                          __global const float16  *plane_matrices,
                          __local const float4 *plane_eqs,
                          __global const unsigned char* bscans_blocks[],
                          int in_xsize,
                          int in_ysize,
                          float in_xspacing,
                          float in_yspacing,
                          __global const unsigned char* mask,
                          float4 voxel);
#endif

#if METHOD == METHOD_DW
unsigned char
performInterpolation_dw(__local close_plane_t *close_planes,
                        int n_close_planes,
                        __global const float16  *plane_matrices,
                        __local const float4 *plane_eqs,
                        __global const unsigned char* bscans_blocks[],
                        int in_xsize,
                        int in_ysize,
                        float in_xspacing,
                        float in_yspacing,
                        __global const unsigned char* mask,
                        float4 voxel);
#endif

#if METHOD == METHOD_ANISOTROPIC
unsigned char
performInterpolation_anisotropic(__local close_plane_t *close_planes,
                            int n_close_planes,
                            __global const float16  *plane_matrices,
                            __local const float4 *plane_eqs,
                            __global const unsigned char* bscans_blocks[],
                            int in_xsize,
                            int in_ysize,
                            float in_xspacing,
                            float in_yspacing,
                            __global const unsigned char* mask,
                            float4 voxel);
#endif

void
prepare_plane_eqs(__global float16 *plane_matrices,
                  __local float4 *plane_eqs);

int
findLocalMinimas(int *guesses,
                 __local float4 *plane_eqs,
                 float4 voxel);

__kernel void
voxel_methods(int volume_xsize,
              int volume_ysize,
              int volume_zsize,
              float volume_xspacing,
              float volume_yspacing,
              float volume_zspacing,
              int in_xsize,
              int in_ysize,
              float in_xspacing,
              float in_yspacing,
              // TODO: Wouldn't it be kind of nice if the bscans was an image sampler object?
              __global unsigned char* in_bscans_b0,
              __global unsigned char* in_bscans_b1,
              __global unsigned char* in_bscans_b2,
              __global unsigned char* in_bscans_b3,
              __global unsigned char* in_bscans_b4,
              __global unsigned char* in_bscans_b5,
              __global unsigned char* in_bscans_b6,
              __global unsigned char* in_bscans_b7,
              __global unsigned char* in_bscans_b8,
              __global unsigned char* in_bscans_b9,
              __global unsigned char* out_volume,
              __global float16 *plane_matrices,
              __global unsigned char* mask,
              __local float4 *plane_eqs,
              __local close_plane_t *planes,
              float radius);



/******************/
/* End prototypes */
/******************/



int isValidPixel(int x,
                 int y,
                 const __global unsigned char* mask,
                 int in_xsize,
                 int in_ysize)
{
#ifndef DEBUG
	return (isInside(x, in_xsize)
	        && isInside(y, in_ysize)
	        && isNotMasked(x, y, mask, in_xsize));
#else
	if((isInside(x, in_xsize)
	    && isInside(y, in_ysize)
	    && isNotMasked(x, y, mask, in_xsize)))
	{
		return 1;
	}
	else {
		//		DEBUG_PRINTF("Pixel %d, %d is not valid! Sizes: %d, %d\n",
		//           x, y, in_xsize, in_ysize);
		return 0;
	}
#endif

}


/**
 * Find the plane with the highest distance to the voxel
 * i.e. the plane with the highest absolute value of dist.
 * Return the index of that plane
 * @param *planes Pointer to first element of plane array
 * @param n size of array pointed to *planes
 */
int
findHighestIdx(__local close_plane_t *planes,
               int n)
{
	int maxidx = 0;
	float maxval = -1.0f;
	planes = &CLOSE_PLANE_IDX(planes, 0);

	for(int i = 0; i < n; i++)
	{
		float abs = fabs(planes->dist);
		if(abs > maxval)
		{
			maxidx = i;
			maxval = abs;
		}
		planes++;
	}
	//	DEBUG_PRINTF("New maxidx: %d maxdist = %f\n", maxidx, maxval);
	BOUNDS_CHECK(maxidx, 0, MAX_PLANES);
	return maxidx;
}

int2
findClosestPlanes_multistart(__local close_plane_t *close_planes,
                            __local float4* const plane_eqs,
                            __global float16* const plane_matrices,
                            const float4 voxel,
                            const float radius,
                            int *multistart_guesses,
                             int n_multistart_guesses,
                             bool doTermDistance,
                             __global const unsigned char* mask,
                            int in_xsize,
                            int in_ysize,
                            float in_xspacing,
                            float in_yspacing)
{

	for(int i = 0; i < MAX_PLANES; i++)
	{
		CLOSE_PLANE_IDX(close_planes, i).dist = INFINITY;
		CLOSE_PLANE_IDX(close_planes, i).plane_id = -1;
	}
	int2 ret;
	int found = 0;
	for(int i = 0; i < n_multistart_guesses; i++)
	{
		ret = findClosestPlanes_heuristic(close_planes,
		                                  plane_eqs,
		                                  plane_matrices,
		                                  voxel,
		                                  radius,
		                                  multistart_guesses[i],
		                                  doTermDistance,
		                                  mask,
		                                  in_xsize,
		                                  in_ysize,
		                                  in_xspacing,
		                                  in_yspacing	);
		if(ret.x > 0)
		{
			multistart_guesses[i] = ret.y;
		}
		found += ret.x;
	}

	ret.x = min(found, MAX_PLANES);
	ret.y = 0;

#ifdef DEBUG
#ifdef CHECK_PLANE_INDICES
	for(int i = 0; i < min(found, MAX_PLANES); i++)
	{
		BOUNDS_CHECK(CLOSE_PLANE_IDX(close_planes, i).plane_id, 0, N_PLANES);
	}
#endif
#endif

	return ret;
}

/**
 * Find planes that are within radius of voxel.
 * Search in both directions in the plane array, starting at guess
 * The assumption is that as you move away from the guess,
 * the distance to this voxel will increase. That assumption may not always be true, for instance
 * if the US probe was swept back and forth.
 * Finds the closest MAX_PLANES planes within radius,
 * provided no plane with distance greater than
 * 2x radius is found before any of the MAX_PLANES closest planes.
 */
int2
findClosestPlanes_heuristic(__local close_plane_t *close_planes,
                            __local float4* const plane_eqs,
                            __global float16* const plane_matrices,
                            const float4 voxel,
                            const float radius,
                            int guess,
                            bool doTermDistance,
                            __global const unsigned char* mask,
                            int in_xsize,
                            int in_ysize,
                            float in_xspacing,
                            float in_yspacing)
{

	
	// Number of planes found so far
	int found = 0;

	// Done condition. .x  = up, .y = down
	int2 done = {0,0};

	// The index of the plane with the smallest distance found so far
	int smallest_idx = guess;

	// The smallest distance found so far
	float smallest_dist = 99999.9f;

	// The index of the plane with the biggest index so far
	int max_idx = 0;

	// The biggest distance found so far
	float max_dist = radius;

	// If guess is 0, we will try to access data for plane id -1, which does not exist.
	// Assume plane 1 is close enough in that case
	if(guess == 0) guess = 1;

	// We won't be changing the guess, but the compiler wouldn't know that
	const int tmp_guess = guess;
	BOUNDS_CHECK(tmp_guess, 1, N_PLANES);
	float2 dists = {dot(voxel, plane_eqs[guess]), dot(voxel, plane_eqs[guess-1])};
	float2 abs_dists = {fabs(dists.x), fabs(dists.y)}; // .x = abs_dist_up, .y = abs_dist_down,

	for(int i = 0; !done.x || !done.y ; i++)
	{
		// Compute the indices of the planes we want to look at.
		int2 idx = {tmp_guess + i, tmp_guess - i - 1};

		float2 prev_abs_dists = abs_dists;

		// Compute the distances to those planes
		dists.x = dot(voxel, plane_eqs[idx.x]);
		dists.y = dot(voxel, plane_eqs[idx.y]);
		// Compute the absolute distances to those planes
		abs_dists.x = fabs(dists.x);
		abs_dists.y =  fabs(dists.y); // .x = abs_dist_up, .y = abs_dist_down,


		float2 diff_dists = prev_abs_dists - abs_dists;

		// Check if the plane is closer than the one farthest away we have included so far
		if(!done.x && abs_dists.x < max_dist)
		{
			BOUNDS_CHECK(idx.x, 0, N_PLANES);
			BOUNDS_CHECK(max_idx, 0, MAX_PLANES);
			int px, py;
			float4 translated_voxel = projectOntoPlaneEq(voxel,
			                                           plane_eqs[idx.x],
			                                           dists.x);
			toImgCoord_int(&px,
			               &py,
			               translated_voxel,
			               plane_matrices[idx.x],
			               in_xspacing,
			               in_yspacing);

			if(isValidPixel(px, py, mask, in_xsize, in_ysize))
			{

				// If yes, swap out the one with the longest distance for this plane
				CLOSE_PLANE_IDX(close_planes, max_idx).dist = dists.x;
				CLOSE_PLANE_IDX(close_planes, max_idx).plane_id = idx.x;
				found++;

				// We have found MAX_PLANES planes, but we don't know they're the closest ones.
				// Find the next candidate for eviction -
				// the plane with the longest distance to the voxel
				max_idx = findHighestIdx(close_planes, MAX_PLANES);
				max_dist = fabs(CLOSE_PLANE_IDX(close_planes, max_idx).dist);

				if(smallest_dist > abs_dists.x && fabs(diff_dists.x) < radius)
				{
					// Update next guess
					smallest_dist = abs_dists.x;
					smallest_idx = idx.x;
				}
			}
		}

		// And the same in the down direction
		// Check if the plane is closer than the one farthest away we have included so far
		if(!done.y && abs_dists.y < max_dist)
		{
			BOUNDS_CHECK(idx.y, 0, N_PLANES);
			BOUNDS_CHECK(max_idx, 0, MAX_PLANES);
			// If yes, swap out the one with the longest distance for this plane
			int px, py;
			float4 translated_voxel = projectOntoPlaneEq(voxel,
			                                           plane_eqs[idx.y],
			                                           dists.y);

			toImgCoord_int(&px,
			               &py,
			               translated_voxel,
			               plane_matrices[idx.y],
			               in_xspacing,
			               in_yspacing);
			if(isValidPixel(px, py, mask, in_xsize, in_ysize))
			{

				CLOSE_PLANE_IDX(close_planes, max_idx).dist = dists.y;
				CLOSE_PLANE_IDX(close_planes, max_idx).plane_id = idx.y;
				found++;
				max_idx = findHighestIdx(close_planes, MAX_PLANES);
				max_dist = fabs(CLOSE_PLANE_IDX(close_planes, max_idx).dist);
				if(smallest_dist > abs_dists.y && fabs(diff_dists.y) < radius)
				{
					// Update next guess
					smallest_dist = abs_dists.y;
					smallest_idx = idx.y;
				}
			}
		}


		// FIXME: The constant here represents a tradeoff between
		// guaranteeing to find all relevant planes, and performance (terminating earlier).
		// This should be investigate further.

		int2 term_dists = {(abs_dists.x > 3.0f*radius)*doTermDistance, (abs_dists.y > 3.0f*radius)*doTermDistance };

		int2 term_radius_jump = {fabs(diff_dists.x) > radius, fabs(diff_dists.y) > radius};
		int2 term_boundaries = {idx.x == N_PLANES-1, idx.y == 0};

		done = done + term_dists + term_boundaries + term_radius_jump;

	}



	int2 ret;
	ret.x = min(found, MAX_PLANES);
	ret.y = smallest_idx;
	return ret;
}


/**
 * Get a pointer to the first pixel of the image frame given by plane_id
 */
__global const unsigned char*
getImageData(int plane_id,
             __global const unsigned char* bscans_blocks[],
             int in_xsize,
             int in_ysize)
{
	int scans_per_block = N_PLANES / N_BLOCKS;
	int n_big_blocks = N_PLANES % N_BLOCKS;
	int block, idx_in_block;
	// Check if plane is in one of the big blocks
	if(plane_id < n_big_blocks * (scans_per_block+1))
	{
		// It's in a big block
		block = plane_id / (scans_per_block+1);
		idx_in_block = plane_id % (scans_per_block+1);
		BOUNDS_CHECK(idx_in_block, 0, scans_per_block+1);
	}
	else
	{
		// It's in a small block
		int index_into_small_blocks = plane_id - (n_big_blocks * (scans_per_block+1));
		idx_in_block = index_into_small_blocks % scans_per_block;
		block = n_big_blocks + (index_into_small_blocks / scans_per_block);
		BOUNDS_CHECK(idx_in_block, 0, scans_per_block);
	}
	BOUNDS_CHECK(block, 0, 10);

	return &bscans_blocks[block][idx_in_block*in_xsize*in_ysize];
}

/**
 * Perform a standard forward transformation of voxel - eqvivalent to multiplying matrix with voxel
 */
float4
transform(float16 matrix,
          float4 voxel)
{
	float4 ret;

	ret.x = matrix.s0*voxel.x + matrix.s1*voxel.y + matrix.s2*voxel.z + matrix.s3;
	ret.y = matrix.s4*voxel.x + matrix.s5*voxel.y + matrix.s6*voxel.z + matrix.s7;
	ret.z = matrix.s8*voxel.x + matrix.s9*voxel.y + matrix.sA*voxel.z + matrix.sB;

	ret.w = 1.0f;
	return ret;

}

/**
 * Perform an inverse transformation of voxel - eqvivalent to multiplying the inverse of the matrix with voxel
 */
float4 transform_inv(float16 matrix,
                     float4 voxel)
{
	float4 ret;
	float4 col0 = matrix.s048C;
	float4 col1 = matrix.s159D;
	float4 col2 = matrix.s26AE;
	float4 col3 = matrix.s37BF;

	ret.x = dot(voxel,col0) - dot(col3,col0);
	ret.y = dot(voxel,col1) - dot(col3,col1);
	ret.z = dot(voxel,col2) - dot(col3,col2);
	ret.w = 1.0f;
	return ret;
}

/**
 * Perform an inverse transformation of voxel, as in transform_inv, but only transform the x and y coordinates. This is useful
 * when finding image coordinates.
 */
float2 transform_inv_xy(float16 matrix, float4 voxel)
{
	float2 ret;
	float4 col0 = matrix.s048C;
	float4 col1 = matrix.s159D;
	float4 col3 = matrix.s37BF;

	ret.x = dot(voxel,col0) - dot(col3,col0);
	ret.y = dot(voxel,col1) - dot(col3,col1);
	return ret;
}

/**
 * Print a matrix - useful for debugging
 */
#ifdef DEBUG
void printMatrix(float16 matrix)
{
	printf("[ %f, %f, %f, %f\n   %f, %f, %f, %f\n   %f, %f, %f, %f\n   %f, %f, %f, %f\n",
	       matrix.s0,
	       matrix.s1,
	       matrix.s2,
	       matrix.s3,
	       matrix.s4,
	       matrix.s5,
	       matrix.s6,
	       matrix.s7,
	       matrix.s8,
	       matrix.s9,
	       matrix.sA,
	       matrix.sB,
	       matrix.sC,
	       matrix.sD,
	       matrix.sE,
	       matrix.sF);
}
#endif

/**
 * Transform to integer image coordinates - i.e. pixel coordinates
 */
void toImgCoord_int(int* x,
                    int* y,
                    float4 voxel,
                    float16 plane_matrix,
                    float in_xspacing,
                    float in_yspacing)
{

	float2 transformed_voxel = transform_inv_xy(plane_matrix, voxel);

	*x = ((transformed_voxel.x/in_xspacing) + 0.5f);
	*y = ((transformed_voxel.y/in_yspacing) + 0.5f);
}

/**
 * Transform to floating point image coordinates
 */
void toImgCoord_float(float* x,
                float* y,
                float4 voxel,
                float16 plane_matrix,
                float in_xspacing,
                float in_yspacing)
{

	float2 transformed_voxel = transform_inv_xy(plane_matrix, voxel);

	*x = ((transformed_voxel.x/in_xspacing));
	*y = ((transformed_voxel.y/in_yspacing));
}


/**
 * Perform bilinear interpolation to retrieve an interpolated pixel value from an image.
 */
float bilinearInterpolation(float x,
                            float y,
                            const __global unsigned char* image,
                            int in_xsize)
{

	// SOURCE: https://en.wikipedia.org/w/index.php?title=Bilinear_interpolation&oldid=574742881 (need better source for report)

	int2 pos = {x, y};
	float2 offset = {x - pos.x, y - pos.y};

	float4 values = { image[pos.x + pos.y*in_xsize],        // Lower left
	                  image[pos.x+1 + pos.y*in_xsize],      // Lower right
	                  image[pos.x + 1 + (pos.y+1)*in_xsize],// Upper right
	                  image[pos.x + (pos.y+1)*in_xsize] };  // Upper left

	float4 weights = { (1.0f - offset.x)*(1.0f - offset.y), // Lower left
	                   (offset.x)*(1.0f - offset.y),        // Lower right
	                   (offset.x)*(offset.y),               // Upper right
	                   (1.0f - offset.x)*(offset.y) };      // Upper left

	return dot(values, weights);

}



#if METHOD == METHOD_VNN
#define PERFORM_INTERPOLATION(a, b, c, d, e, f, g, h, i , j, k)	  \
	performInterpolation_vnn(a, b, c, d, e, f, g, h, i, j, k)

/**
 * Perform interpolation using the Voxel Nearest Neighbour method.
 * This works by taking finding the plane closest to the voxel,
 * projecting the voxel orthogonally onto the image plane to find pixel coordinates
 * and taking the pixel value
 */
unsigned char
performInterpolation_vnn(__local close_plane_t *close_planes,
                         int n_close_planes,
                         __global const float16  *plane_matrices,
                         __local const float4 *plane_eqs,
                         __global const unsigned char* bscans_blocks[],
                         int in_xsize,
                         int in_ysize,
                         float in_xspacing,
                         float in_yspacing,
                         __global const unsigned char* mask,
                         float4 voxel)
{
	if(n_close_planes == 0) return 1;

	int plane_id = 0;
	float lowest_dist = 10.0f;
	int close_plane_id = 0;

	// Find the closest plane
	for(int i = 0; i < n_close_planes;  i++)
	{
		float fabs_dist = fabs(CLOSE_PLANE_IDX(close_planes, i).dist);
		if(fabs_dist < lowest_dist)
		{
			lowest_dist = fabs_dist;
			plane_id = CLOSE_PLANE_IDX(close_planes ,i).plane_id;
			close_plane_id = i;
		}
	}
	BOUNDS_CHECK(plane_id, 0, N_PLANES);
	const __global unsigned char* image = getImageData(plane_id,
	                                                   bscans_blocks,
	                                                   in_xsize,
	                                                   in_ysize);

	// Now we project the voxel onto the plane by translating the voxel along the
	// normal vector of the plane.
	float4 translated_voxel = projectOntoPlane(voxel,
	                                           plane_matrices[plane_id],
	                                           CLOSE_PLANE_IDX(close_planes ,close_plane_id).dist);
	translated_voxel.w = 1.0f;


	// And then we get the pixel space coordinates
	int x, y;
	toImgCoord_int(&x,
	               &y,
	               translated_voxel,
	               plane_matrices[plane_id],
	               in_xspacing,
	               in_yspacing);

	if(!isValidPixel(x,y, mask, in_xsize, in_ysize))
	{
		return 1;
	}
	BOUNDS_CHECK(x, 0, in_xsize);
	BOUNDS_CHECK(y, 0, in_ysize);
	return max((unsigned char)1, image[y*in_xsize + x]);

}
#endif

#if METHOD == METHOD_VNN2
#define PERFORM_INTERPOLATION(a, b, c, d, e, f, g, h, i ,j, k)	  \
	performInterpolation_vnn2(a, b, c, d, e, f, g, h, i, j, k)

/**
 * Perform interpolation using the VNN2 method. For each close plane, add (1/dist)*closest_pixel_value to the sum.
 * In the end, divide sum by sum(1/dist), and you have your voxel value.
 */
unsigned char
performInterpolation_vnn2(__local close_plane_t *close_planes,
                          int n_close_planes,
                          __global const float16  *plane_matrices,
                          __local const float4 *plane_eqs,
                          __global const unsigned char* bscans_blocks[],
                          int in_xsize,
                          int in_ysize,
                          float in_xspacing,
                          float in_yspacing,
                          __global const unsigned char* mask,
                          float4 voxel)
{
	if(n_close_planes == 0) return 1;


	float scale = 0.0f;

	float val = 0;
	for(int i = 0; i < n_close_planes; i++)
	{

		int plane_id = CLOSE_PLANE_IDX(close_planes ,i).plane_id;
		const __global unsigned char* image = getImageData(CLOSE_PLANE_IDX(close_planes ,i).plane_id,
		                                             bscans_blocks,
		                                             in_xsize,
		                                             in_ysize);


		// Now we project the voxel onto the plane by translating the voxel along the
		// normal vector of the plane.
		voxel.w = 1.0f;
		float4 translated_voxel = projectOntoPlaneEq(voxel,
		                                             plane_eqs[plane_id],
		                                             CLOSE_PLANE_IDX(close_planes ,i).dist);

		translated_voxel.w = 1.0f;
		// And then we get the pixel space coordinates
		int x, y;
		toImgCoord_int(&x,
		               &y,
		               translated_voxel,
		               plane_matrices[plane_id],
		               in_xspacing,
		               in_yspacing);

		if(!isValidPixel(x,y, mask, in_xsize, in_ysize))
		{
			continue;
		}
		float dist = fabs(CLOSE_PLANE_IDX(close_planes ,i).dist);

		if(dist < 0.001f)
			dist = 0.001f;
		float weight = VNN2_WEIGHT(dist);

		scale += weight;
		val += (image[y*in_xsize + x] * weight);
	}


	return max((unsigned char)1, (unsigned char) (val / scale));

}
#endif

#if METHOD == METHOD_DW
#define PERFORM_INTERPOLATION(a, b, c, d, e, f, g, h, i ,j, k)	  \
	performInterpolation_dw(a, b, c, d, e, f, g, h, i, j, k)

/**
 * Perform interpolation using the DW method. Works the same as VNN2, but instead of taking the closest pixel on each image plane,
 * the value from each plane is a bilinearly interpolated from that plane.
 */
unsigned char
performInterpolation_dw(__local close_plane_t *close_planes,
                        int n_close_planes,
                        __global const float16  *plane_matrices,
                        __local const float4 *plane_eqs,
                        __global const unsigned char* bscans_blocks[],
                        int in_xsize,
                        int in_ysize,
                        float in_xspacing,
                        float in_yspacing,
                        __global const unsigned char* mask,
                        float4 voxel)
{


	if(n_close_planes == 0) return 1;


	float scale = 0.0f;

	float val = 0;
	for(int i = 0; i < n_close_planes; i++)
	{

		int plane_id = CLOSE_PLANE_IDX(close_planes ,i).plane_id;
		const __global unsigned char* image = getImageData(CLOSE_PLANE_IDX(close_planes ,i).plane_id,
		                                                   bscans_blocks,
		                                                   in_xsize,
		                                                   in_ysize);


		// Now we project the voxel onto the plane by translating the voxel along the
		// normal vector of the plane.
		voxel.w = 1.0f;
		float4 translated_voxel = projectOntoPlaneEq(voxel,
		                                             plane_eqs[plane_id],
		                                             CLOSE_PLANE_IDX(close_planes ,i).dist);

		translated_voxel.w = 1.0f;
		// And then we get the pixel space coordinates
		float x, y;
		toImgCoord_float(&x,
		           &y,
		           translated_voxel,
		           plane_matrices[plane_id],
		           in_xspacing,
		           in_yspacing);


		int ix, iy;
		ix = x;
		iy = y;
		if(!isValidPixel(ix,iy, mask, in_xsize, in_ysize)
		   || !isValidPixel(ix+1, iy, mask, in_xsize, in_ysize)
		   || !isValidPixel(ix+1, iy+1, mask, in_xsize, in_ysize)
		   || !isValidPixel(ix, iy+1, mask, in_xsize, in_ysize)
			)
		{
			continue;
		}

		float interpolated_value = bilinearInterpolation(x, y, image, in_xsize);

		float dist = fabs(CLOSE_PLANE_IDX(close_planes ,i).dist);
		if(dist < 0.001f) dist = 0.001f;
		float weight = DW_WEIGHT(dist);
		scale += weight;
		val += (interpolated_value * weight);
	}


	return max((unsigned char)1, (unsigned char) (val / scale));

}
#endif

#if METHOD == METHOD_ANISOTROPIC
#define PERFORM_INTERPOLATION(a, b, c, d, e, f, g, h, i ,j, k)	  \
	performInterpolation_anisotropic(a, b, c, d, e, f, g, h, i, j, k)

/**
 * Perform interpolation using an anisotropic filter
 */
unsigned char
performInterpolation_anisotropic(__local close_plane_t *close_planes,
                            int n_close_planes,
                            __global const float16  *plane_matrices,
                            __local const float4 *plane_eqs,
                            __global const unsigned char* bscans_blocks[],
                            int in_xsize,
                            int in_ysize,
                            float in_xspacing,
                            float in_yspacing,
                            __global const unsigned char* mask,
                            float4 voxel)
{
	// First, find all the relevant pixels
#if ANISOTROPIC_METHOD == ANISOTROPIC_METHOD_INCLUDE_ALL
	pixel_t pixels[MAX_PLANES*ANISOTROPIC_SIZE*ANISOTROPIC_SIZE];
#elif ANISOTROPIC_METHOD == ANISOTROPIC_METHOD_BILINEAR_ON_PLANE
	pixel_t pixels[MAX_PLANES];
#elif ANISOTROPIC_METHOD == ANISOTROPIC_METHOD_GAUSSIAN_ON_PLANE
	pixel_t pixels[MAX_PLANES];
#endif


	int pos = 0;
	for(int i = 0; i < n_close_planes; i++)
	{
		const int plane_id = CLOSE_PLANE_IDX(close_planes ,i).plane_id;
		const __global unsigned char* image = getImageData(plane_id,
		                                             bscans_blocks,
		                                             in_xsize,
		                                             in_ysize);

		// Project onto plane
		voxel.w = 1.0f;
		float4 translated_voxel = projectOntoPlaneEq(voxel,
		                                             plane_eqs[plane_id],
		                                             CLOSE_PLANE_IDX(close_planes ,i).dist);
		translated_voxel.w = 1.0f;


#if ANISOTROPIC_METHOD == ANISOTROPIC_METHOD_INCLUDE_ALL

		int x, y;
		toImgCoord_int(&x,
		               &y,
		               translated_voxel,
		               plane_matrices[plane_id],
		               in_xspacing,
		               in_yspacing);

		for(int j = -ANISOTROPIC_SIZE/2; j <= ANISOTROPIC_SIZE/2; j++)
		{
			for(int k = -ANISOTROPIC_SIZE/2; k <= ANISOTROPIC_SIZE/2; k++)
			{
				int _x = x + j;
				int _y = y + k;
				if(!isValidPixel(_x, _y, mask, in_xsize, in_ysize))
				{
					continue;
				}
				pixels[pos].intensity = image[_y*in_xsize + _x];


				// We know the distance in the direction normal to the plane.
				// Since this is a pixel _on_ the plane, pretend the distance along the
				// normal is one cathete, and the distance on the image plane is another catethe.
				// The distance is then the hypotenuse.

				float dist_x = j*in_xspacing;
				float dist_y = k*in_yspacing;
				float sq_x = dist_x*dist_x;
				float sq_y = dist_y*dist_y;
				float cp_dist = CLOSE_PLANE_IDX(close_planes ,i).dist;
				pixels[pos].dist = sqrt(cp_dist*cp_dist + sq_x + sq_y);
				pos++;
			}
		}

#elif ANISOTROPIC_METHOD == ANISOTROPIC_METHOD_BILINEAR_ON_PLANE
		float x, y;
		toImgCoord_float(&x,
		                 &y,
		                 translated_voxel,
		                 plane_matrices[plane_id],
		                 in_xspacing,
		                 in_yspacing);


		int ix, iy;
		ix = x;
		iy = y;
		if(!isValidPixel(ix,iy, mask, in_xsize, in_ysize)
		   || !isValidPixel(ix+1, iy, mask, in_xsize, in_ysize)
		   || !isValidPixel(ix+1, iy+1, mask, in_xsize, in_ysize)
		   || !isValidPixel(ix, iy+1, mask, in_xsize, in_ysize)
				)
			{
			continue;
		}
		pixels[pos].intensity = bilinearInterpolation(x,
		                                              y,
		                                              image,
		                                              in_xsize);
		pixels[pos++].dist = CLOSE_PLANE_IDX(close_planes, i).dist;

#elif ANISOTROPIC_METHOD == ANISOTROPIC_METHOD_GAUSSIAN_ON_PLANE
		int x, y;
		toImgCoord_int(&x,
		               &y,
		               translated_voxel,
		               plane_matrices[plane_id],
		               in_xspacing,
		               in_yspacing);
		float gauss_weight_sum = 0.0f;
		float gauss_value = 0.0f;
		for(int ix = 0; ix < ANISOTROPIC_GAUSSIAN_SIZE; ix++)
		{
			for(int iy = 0; iy < ANISOTROPIC_GAUSSIAN_SIZE; iy++)
			{
				int xpos = x + ix - ANISOTROPIC_GAUSSIAN_SIZE/2;
				int ypos = y + iy - ANISOTROPIC_GAUSSIAN_SIZE/2;
				int xmaskpos = xpos - x;
				int ymaskpos = ypos - y;
				if(!isValidPixel(xpos, ypos, mask, in_xsize, in_ysize))
				{
					// If the pixel is invalid, we simply ignore that pixel
					continue;
				}

				float weight = WEIGHT_GAUSS(hypot((float)xmaskpos, (float)ymaskpos), 0.5f);
				gauss_value = mad(weight,image[xpos + ypos*in_xsize], gauss_value);
				gauss_weight_sum += weight;
			}
		}
		pixels[pos].intensity = gauss_value / gauss_weight_sum;
		pixels[pos++].dist = CLOSE_PLANE_IDX(close_planes, i).dist;
#endif

	}


	if(pos == 0)
	{
		return 1;
	}

	//return max((unsigned char)1, weighted_median(pixels, pos).intensity);
	return max((unsigned char)1, anisotropicFilter(pixels, pos).intensity);

}



pixel_t anisotropicFilter(const pixel_t *pixels,
                          int n_planes)
{
	// Calculate the variance

	float mean_value = 0.0f;
	for(int i = 0; i < n_planes; i++)
	{
		mean_value += pixels[i].intensity;
	}

	mean_value = mean_value / n_planes;

	float variance = 0.0f;
	for(int i = 0; i < n_planes; i++)
	{
		float tmp = pixels[i].intensity - mean_value;
		variance  += mad(tmp, tmp, variance);
 	}

	// We want high variance regions to have a sharp weight function
	// and small variance regions to have a smooth weight function.


	variance = clamp(variance/(n_planes-1), 1.0f, 10000.0f);
	float gauss_sigma = mean_value/sqrt(variance);

#ifdef DEBUG
	if(variance > 0.1f && mean_value> 10.0f)
		DEBUG_PRINTF("Mean: %f, variance: %f, sigma: %f\n", mean_value, variance, gauss_sigma);
#endif

	float sum_weights = 0.0f;
	float sum = 0.0f;
	// Use the resulting gauss sigma to calcualte weights
	for(int i = 0; i < n_planes; i++)
	{
		float weight = WEIGHT_GAUSS(pixels[i].dist, gauss_sigma);
		sum = mad(pixels[i].intensity,weight, sum);
		sum_weights += weight;
	}

	pixel_t ret;
	ret.dist = 0.0f;
	ret.intensity = sum / sum_weights;
	return ret;
}



#endif
/**
 * Build the plane equations from the matrices and store them in local memory
 */
void
prepare_plane_eqs(__global float16 *plane_matrices,
                 __local float4 *plane_eqs)
{
	int id = get_local_id(0);
	int max_local_id = get_local_size(0);
	const int n_planes_pr_thread = (N_PLANES / max_local_id) + 1;

	for(int i = 0; i < n_planes_pr_thread; i++)
	{
		int idx = i + n_planes_pr_thread * id;
		if(idx >= N_PLANES) break;
		plane_eqs[idx].xyz = plane_matrices[idx].s26A;
		plane_eqs[idx].w = -dot(plane_matrices[idx].s26AE, plane_matrices[idx].s37BF);
	}
	barrier(CLK_LOCAL_MEM_FENCE);
}

int findLocalMinimas(int *guesses,
                     __local float4 *plane_eqs,
                     float4 voxel)

{
	// Find all valleys in the search space of distances.
	// We don't need the _exact_ minima, however it should be inside the sweep we want.
	// However, the input data are noisy, so local minima in its strictest sense does not work for us.
	// But if we can find two indices a and b, such that dist(i) < dist(a) and dist(i) < dist(b)
	// and b - a = LOCAL_SEARCH_DISTANCE, it's a good chance it's a minima.

	int nMinima = 0;

	for(int i = 0;
	    i < N_PLANES &&
		    nMinima < MAX_MULTISTART_STARTS;
	    i++)
	{

		/* int a = max(0, i - LOCAL_SEARCH_DISTANCE); */
		/* int b = min(N_PLANES-1, i + LOCAL_SEARCH_DISTANCE); */
		int a = i - LOCAL_SEARCH_DISTANCE;
		int b = i + LOCAL_SEARCH_DISTANCE;
		float a_dist, b_dist;
		float i_dist = fabs(dot(plane_eqs[i], voxel));

		// TODO: Unroll the end cases? Lots of branching for a quite bad reason here..
		if(a < 0) a_dist = INFINITY;
		else a_dist = fabs(dot(plane_eqs[a], voxel));

		if(b >= N_PLANES) b_dist = INFINITY;
		else b_dist = fabs(dot(plane_eqs[b], voxel));

		if(a_dist > i_dist && b_dist > i_dist)
		{
			// We are inside a local minima. Now, how do we know we haven't found this minima before?
			// We require that they be spaced by at least LOCAL_SEARCH_DISTANCE.
			// However, if this minima is better (i.e. closer) than the previous one
			// inside LOCAL_SEARCH_DISTANCE,
			// of course we want to use this one.
			if(nMinima > 0 && guesses[nMinima-1] - i < LOCAL_SEARCH_DISTANCE*2)
			{
				DEBUG_PRINTF("Minima %d: Found nearby minima: %d : %f\n", nMinima, i, i_dist);
				// We have a previous minima, and it's too close.
				float prev_dist = fabs(dot(plane_eqs[guesses[nMinima-1]], voxel));
				if(i_dist < prev_dist)
				{
					DEBUG_PRINTF("Taking it\n");
					// But this one is better, lets use it
					guesses[nMinima-1] = i;
				}
			}
			else
			{
				// We may simply store this minima
				DEBUG_PRINTF("Minima %d: Found new minima: %d : %f\n", nMinima, i, i_dist);
				guesses[nMinima] = i;
				nMinima++;
			}
		}
	}
	DEBUG_PRINTF("Found %d minima in total\n", nMinima);
	
	return nMinima;
}

/** The entry point for this set of reconstruction methods.
 * Parameters:
 * @param volume_xsize Size of output volume, X direction
 * @param volume_ysize Size of output volume, Y direction
 * @param volume_zsize Size of output volume, Z direction
 * @param volume_xspacing Voxel size of output volume, X direction
 * @param volume_yspacing Voxel size of output volume, Y direction
 * @param volume_zspacing Voxel size of output volume, Z direction
 * @param in_xsize Size of each ultrasound input image in pixels, X direction
 * @param in_ysize Size of each ultrasound input image in pixels, Y direction
 * @param in_xspacing Size of each pixel in input ultrasound images, X direction
 * @param in_yspacing Size of each pixel in input ultrasound images, Y direction
 * @param in_bscans_b_ Ultrasound input images
 * @param out_volume Output volume - reconstructed volume goes here
 * @param plane_matrices One matrix per image plane specifying the transform from pixel space to voxel space
 * @param plane_eqs Pointer to local memory where we will store plane equations
 * @param radius The radius of the kernel - how far away to accept voxels from.
 */
__kernel void
voxel_methods(int volume_xsize,
              int volume_ysize,
              int volume_zsize,
              float volume_xspacing,
              float volume_yspacing,
              float volume_zspacing,
              int in_xsize,
              int in_ysize,
              float in_xspacing,
              float in_yspacing,
              // TODO: Wouldn't it be kind of nice if the bscans was an image sampler object?
              __global unsigned char* in_bscans_b0,
              __global unsigned char* in_bscans_b1,
              __global unsigned char* in_bscans_b2,
              __global unsigned char* in_bscans_b3,
              __global unsigned char* in_bscans_b4,
              __global unsigned char* in_bscans_b5,
              __global unsigned char* in_bscans_b6,
              __global unsigned char* in_bscans_b7,
              __global unsigned char* in_bscans_b8,
              __global unsigned char* in_bscans_b9,
              __global unsigned char* out_volume,
              __global float16 *plane_matrices,
              __global unsigned char *mask,
              __local float4 *plane_eqs,
              __local close_plane_t *close_planes,
              float radius
	)
{

	int id = get_global_id(0);
	int x = id % volume_xsize;
	int z = id / volume_xsize;
	#ifdef DEBUG
	if(id == 5000)
		BOUNDS_CHECK(id, 0, 1);
	#endif
	// Aggregate pointers to the bscan blocks into one array for convenience

	const __global unsigned char *bscans_blocks[] = { in_bscans_b0,
	                                            in_bscans_b1,
	                                            in_bscans_b2,
	                                            in_bscans_b3,
	                                            in_bscans_b4,
	                                            in_bscans_b5,
	                                            in_bscans_b6,
	                                            in_bscans_b7,
	                                            in_bscans_b8,
	                                            in_bscans_b9 };


	// For most of these algorithms we need to find some set of close planes.
	// We find all planes that are inside the voxel radius
	//	__local close_plane_t close_planes[(MAX_PLANES+1)*get_local_size(0)];
	int n_close_planes;

	float4 voxel = {x * volume_xspacing,
	                0.0f,
	                z * volume_zspacing,
	                1.0f};
	// Find the plane closest to the initial voxel


	prepare_plane_eqs(plane_matrices, plane_eqs);


	// Return if x/z is invalid

	if(z >= volume_zsize) return;
	if(x >= volume_xsize) return;
	BOUNDS_CHECK(x, 0, volume_xsize);
	BOUNDS_CHECK(z, 0, volume_zsize);

	int multistart_guesses[MAX_MULTISTART_STARTS];

	int nGuesses = findLocalMinimas(multistart_guesses,
	                                plane_eqs,
	                                voxel);

#ifdef DEBUG
	for(int i = 0; i < nGuesses; i++)
	{
		DEBUG_PRINTF("Multistart %d: idx %d dist %f\n",i,
		             multistart_guesses[i],
		             fabs(dot(voxel, plane_eqs[multistart_guesses[i]])));
	}
#endif

	int2 close_planes_ret;
	// Iterate over Y axis
	for(int y = 0; y < volume_ysize; y++)
	{
		BOUNDS_CHECK(z, 0, volume_xsize);


		voxel.y = y*volume_yspacing;

		// Find all planes closer than radius

		close_planes_ret = FIND_CLOSE_PLANES(close_planes,
		                                     plane_eqs,
		                                     plane_matrices,
		                                     voxel,
		                                     radius,
		                                     multistart_guesses,
		                                     nGuesses,
		                                     mask,
		                                     in_xsize,
		                                     in_ysize,
		                                     in_xspacing,
		                                     in_yspacing);
		n_close_planes = close_planes_ret.x;



		// Call appropriate method to determine pixel value
		VOXEL(out_volume,x,y,z) = PERFORM_INTERPOLATION(close_planes,
		                                                n_close_planes,
		                                                plane_matrices,
		                                                plane_eqs,
		                                                bscans_blocks,
		                                                in_xsize,
		                                                in_ysize,
		                                                in_xspacing,
		                                                in_yspacing,
		                                                mask,
		                                                voxel);

		//VOXEL(out_volume, x, y, z) = x;
		//VOXEL(out_volume, x, y, z) = ((float)z/(float)volume_zsize) * 255;
		//VOXEL(out_volume, x,y,z) = 1;

	}
}
