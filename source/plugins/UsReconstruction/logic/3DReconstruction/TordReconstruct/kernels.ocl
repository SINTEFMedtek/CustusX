

// At current, this is a temporary playground file for Tord

typedef struct _close_plane
{
	float dist;
	int plane_id;
	int4 pad;
} close_plane_t;

#define MAX_PLANES 24
#define N_BLOCKS 10

#define METHOD_VNN 0
#define METHOD_VNN2 1

#define VOXEL(v,x,y,z) v[x + y*volume_xsize + z*volume_ysize*volume_xsize]

//#define DEBUG

#ifdef DEBUG

#define DEBUG_PRINTF(...) printf(##__VA_ARGS__)

#else

#define DEBUG_PRINTF(...)

#endif


float plane_dist(const float4 voxel, const float16 matrix)
{
	//	float4 z_axis = matrix.s89AB;
	float4 z_axis = matrix.s26AE;
		z_axis.w = 0.0f;
	float4 trans = matrix.s37BF;
	//	voxel.w = 1;
	return dot(z_axis, voxel) - dot(z_axis, trans);
}

float4 projectOntoPlane(const float4 voxel, const float16 matrix, const float dist)
{
	float4 z_axis = matrix.s26AE;
	
	return voxel - dist*(voxel * z_axis); 
} 


	
	
/** Find all planes that are within radius of voxel.
    Perform a simple linear search for now.
    May need to optimize this.
    It spends ~50% of the time in here!
*/
int
findClosePlanes(close_plane_t *close_planes,
                __global float16* const plane_matrices,
                int n_planes,
                float4 voxel,
                float radius,
                int* guess)
{
	int found = 0;

	float smallest_dist = 999999.0f;

	int nextguess = *guess;
	voxel.w = 1;
	int done_up = 0, done_down = 0;
	float prev_dist_up  = 999999.0f;
	float prev_dist_down  = 999999.0f;
	for(int i = 0; !done_up || !done_down; i++)
	{
		
		
		if(!done_up)
		{
			int idx = *guess + i;

			float dist = plane_dist(voxel, plane_matrices[idx]);
			float abs_dist = fabs(dist);
			if(abs_dist < radius)
			{
				close_planes->dist = dist;
				close_planes->plane_id = idx;
				close_planes++;
				found++;
				if(smallest_dist > abs_dist)
				{
					nextguess = idx;
					smallest_dist = abs_dist;
				}
				if(found == MAX_PLANES)
				{
					*guess = nextguess;
					return found;
				}
			}
			if((abs_dist - prev_dist_up > 2.0f && found) || idx == n_planes-1)
			{
				// If we're at the distance 2*radius and moving further away,
				// and we have already found something, don't keep going
				done_up = 1;
			}
			prev_dist_up = abs_dist;
		}
	

		// Do the same thing looking downwards
		if(!done_down) {
			int idx = *guess - i;
			float dist = plane_dist(voxel, plane_matrices[idx]);
			float abs_dist = fabs(dist);
			if(abs_dist < radius)
			{	
				close_planes->dist = dist;
				close_planes->plane_id = idx;
				close_planes++;
				found++;
				if(smallest_dist > dist)
				{
					nextguess = idx;
					smallest_dist = abs_dist;
				}
				if(found == MAX_PLANES)
				{
					*guess = nextguess;
					return found;
				}
			}
			if((abs_dist - prev_dist_down > 2.0f && found) || idx == 0)
			{
				// If we're at the distance 2*radius and moving further away,
				// and we have already found something, don't keep going
				done_down = 1;
			}
			prev_dist_down = abs_dist;
		}
	}
	*guess = nextguess;
	return found;
}


__global const unsigned char*
getImageData(int plane_id,
             __global const unsigned char* bscans_blocks[],
             int in_xsize,
             int in_ysize,
             int n_planes)
{
	int scans_per_block = n_planes / N_BLOCKS;
	int n_big_blocks = n_planes % N_BLOCKS;
	int block, idx_in_block;
	// Check if plane is in one of the big blocks
	if(plane_id < n_big_blocks * (scans_per_block+1))
	{
		// It's in a big block
		block = plane_id / (scans_per_block+1);
		idx_in_block = plane_id % (scans_per_block+1);
	}
	else
	{
		// It's in a small block
		int index_into_small_blocks = plane_id - (n_big_blocks * (scans_per_block+1));
		idx_in_block = index_into_small_blocks % scans_per_block;
		block = n_big_blocks + (index_into_small_blocks / scans_per_block);
	}
	return &bscans_blocks[block][idx_in_block*in_xsize*in_ysize];
}

float4 transform(float16 matrix,
                 float4 voxel)
{
	float4 ret;
	
	ret.x = matrix.s0*voxel.x + matrix.s1*voxel.y + matrix.s2*voxel.z + matrix.s3;
	ret.y = matrix.s4*voxel.x + matrix.s5*voxel.y + matrix.s6*voxel.z + matrix.s7;
	ret.z = matrix.s8*voxel.x + matrix.s9*voxel.y + matrix.sA*voxel.z + matrix.sB;
	
	ret.w = 1.0f;
	return ret;

}
float4 transform_inv(float16 matrix,
                     float4 voxel)
{
	float4 ret;
	float4 col0 = matrix.s048C;
	float4 col1 = matrix.s159D;
	float4 col2 = matrix.s26AE;
	float4 col3 = matrix.s37BF;
	
	ret.x = dot(voxel,col0) - dot(col3,col0);
	ret.y = dot(voxel,col1) - dot(col3,col1);
	ret.z = dot(voxel,col2) - dot(col3,col2);
	
	/*ret.x = dot(voxel,col0);
	ret.y = dot(voxel,col1);
	ret.z = dot(voxel,col2);

	ret -= col3; */
	return ret;
}

void printMatrix(float16 matrix)
{
	printf("[ %f, %f, %f, %f\n   %f, %f, %f, %f\n   %f, %f, %f, %f\n   %f, %f, %f, %f\n",
	       matrix.s0,
	       matrix.s1,
	       matrix.s2,
	       matrix.s3,
	       matrix.s4,
	       matrix.s5,
	       matrix.s6,
	       matrix.s7,
	       matrix.s8,
	       matrix.s9,
	       matrix.sA,
	       matrix.sB,
	       matrix.sC,
	       matrix.sD,
	       matrix.sE,
	       matrix.sF);
}
	       


void toImgCoord(int* x,
                int* y,
                float4 voxel,
                float16 plane_matrix,
                float in_xspacing,
                float in_yspacing)
{
	DEBUG_PRINTF("Voxel: %f, %f, %f, %f\n",voxel.x, voxel.y, voxel.z, voxel.w);

	float4 transformed_voxel = transform_inv(plane_matrix, voxel);

	*x = transformed_voxel.x/in_xspacing;
	*y = transformed_voxel.y/in_yspacing;
}


int isValidPixel(int x, int y, int in_xsize, int in_ysize)
{
	if(x < 0 || x >= in_xsize)
	{
		return 0;
	}
	if( y < 0 || y >= in_ysize)
	{
		return 0;
	}
	return 1;
}

unsigned char
performInterpolation_vnn(close_plane_t *close_planes,
                         int n_close_planes,
                         __global const float16  *plane_matrices, 
                         __global const unsigned char* bscans_blocks[],
                         int in_xsize,
                         int in_ysize,
                         float in_xspacing,
                         float in_yspacing,
                         float4 voxel,
                         int n_planes)
{
                                      

	if(n_close_planes == 0) return 1;
	

	int plane_id = 0;
	float lowest_dist = 10.0f;
	int close_plane_id = 0;
	for(int i = 0; i < n_close_planes;  i++)
	{
		if(fabs(close_planes[i].dist) < fabs(lowest_dist))
		{
			lowest_dist = close_planes[i].dist;
			plane_id = close_planes[i].plane_id;
			close_plane_id = i;
		}
	} 
			
		__global unsigned char* image = getImageData(plane_id,
		                                             bscans_blocks,
		                                             in_xsize,
		                                             in_ysize,
		                                             n_planes); 

	// Now we project the voxel onto the plane by translating the voxel along the
	// normal vector of the plane.
	
	float4 translated_voxel = projectOntoPlane(voxel,
	                                           plane_matrices[plane_id],
	                                           close_planes[close_plane_id].dist);
	
	
	
	// And then we get the pixel space coordinates
	int x, y;
	toImgCoord(&x,
	           &y,
	           voxel,
	           plane_matrices[plane_id],
	           in_xspacing,
	           in_yspacing);

	if(!isValidPixel(x,y, in_xsize, in_ysize))
	{
		return 1;
	}
	return max((unsigned char)1, image[y*in_xsize + x]);
	//return (unsigned char)(x % 255);
}


unsigned char
performInterpolation_vnn2(close_plane_t *close_planes,
                          int n_close_planes,
                          __global const float16  *plane_matrices, 
                          __global const unsigned char* bscans_blocks[],
                          int in_xsize,
                          int in_ysize,
                          float in_xspacing,
                          float in_yspacing,
                          float4 voxel,
                          int n_planes)
{
                                      

	if(n_close_planes == 0) return 1;
	

	float scale = 0.0f;
	
	float val = 0;
	for(int i = 0; i < n_close_planes; i++)
	{

		int plane_id = close_planes[i].plane_id;
		__global unsigned char* image = getImageData(close_planes[i].plane_id,
		                                             bscans_blocks,
		                                             in_xsize,
		                                             in_ysize,
		                                             n_planes);


		// Now we project the voxel onto the plane by translating the voxel along the
		// normal vector of the plane.
	
		float4 translated_voxel = projectOntoPlane(voxel,
		                                           plane_matrices[plane_id],
		                                           close_planes[i].dist);
	
	
		// And then we get the pixel space coordinates
		int x, y;
		toImgCoord(&x,
		           &y,
		           translated_voxel,
		           plane_matrices[plane_id],
		           in_xspacing,
		           in_yspacing);

		if(!isValidPixel(x,y, in_xsize, in_ysize))
		{
			continue;
		}
		float dist = fabs(close_planes[i].dist);
		scale += 1.0f/dist;
		val += (image[y*in_xsize + x] * 1.0f/dist);
	}		

	
	return (unsigned char) (val / scale);
	
}


unsigned char
performInterpolation(close_plane_t *close_planes,
                     int n_close_planes,
                     __global const float16  *plane_matrices, 
                     __global const unsigned char* bscans_blocks[],
                     int in_xsize,
                     int in_ysize,
                     float in_xspacing,
                     float in_yspacing,
                     float4 voxel,
                     int n_planes,
                     int method
	)
{
	unsigned char value = 0;
	if(method == METHOD_VNN)
	{
		value = performInterpolation_vnn(close_planes,
		                                 n_close_planes,
		                                 plane_matrices,
		                                 bscans_blocks,
		                                 in_xsize,
		                                 in_ysize,
		                                 in_xspacing,
		                                 in_yspacing,
		                                 voxel,
		                                 n_planes);
	} else if (method == METHOD_VNN2)
	{
		value = performInterpolation_vnn2(close_planes,
		                                  n_close_planes,
		                                  plane_matrices,
		                                  bscans_blocks,
		                                  in_xsize,
		                                  in_ysize,
		                                  in_xspacing,
		                                  in_yspacing,
		                                  voxel,
		                                  n_planes);
	}
	return max((unsigned char)1,value);
}
	

__kernel void
voxel_methods(int volume_xsize,
              int volume_ysize,
              int volume_zsize,
              float volume_xspacing,
              float volume_yspacing,
              float volume_zspacing,
               int in_xsize,
              int in_ysize,
              int n_planes,
              float in_xspacing,
              float in_yspacing,
              // TODO: Wouldn't it be kind of nice if the bscans was an image sampler object?
              __global unsigned char* in_bscans_b0,
              __global unsigned char* in_bscans_b1,
              __global unsigned char* in_bscans_b2,
              __global unsigned char* in_bscans_b3,
              __global unsigned char* in_bscans_b4,
              __global unsigned char* in_bscans_b5,
              __global unsigned char* in_bscans_b6,
              __global unsigned char* in_bscans_b7,
              __global unsigned char* in_bscans_b8,
              __global unsigned char* in_bscans_b9,
              __global unsigned char* out_volume,
              __global float16 *plane_matrices, 
              float radius,
              int method
	)
{

	int id = get_global_id(0);
	int x = id % volume_xsize;
	int z = id / volume_xsize;

	// Aggregate pointers to the bscan blocks into one array for convenience
	
	__global unsigned char *bscans_blocks[] = { in_bscans_b0,
	                                            in_bscans_b1,
	                                            in_bscans_b2,
	                                            in_bscans_b3,
	                                            in_bscans_b4,
	                                            in_bscans_b5,
	                                            in_bscans_b6,
	                                            in_bscans_b7,
	                                            in_bscans_b8,
	                                            in_bscans_b9 };
	                             
	// Return if x/z is invalid
	
	if(z >= volume_zsize) return;
	if(x >= volume_xsize) return;
	
	// For most of these algorithms we need to find some set of close planes.
	// We find all planes that are inside the voxel radius
	close_plane_t close_planes[MAX_PLANES];
	int n_close_planes;
	int guess = 0;
	// Iterate over Y axis
	for(int y = 0; y < volume_ysize; y++)
	{
		// Transform voxel to volume space
		float4 voxel = {x * volume_xspacing,
		                y * volume_yspacing,
		                z * volume_zspacing,
		                1.0f};
		

		// Find all planes closer than radius
		n_close_planes = findClosePlanes(close_planes, plane_matrices, n_planes, voxel, radius,
		                                 &guess);
		
		// Call appropriate method to determine pixel value
		VOXEL(out_volume,x,y,z) = performInterpolation(close_planes,
		                                               n_close_planes,
		                                               plane_matrices,
		                                               bscans_blocks,
		                                               in_xsize,
		                                               in_ysize,
		                                               in_xspacing,
		                                               in_yspacing,
		                                               voxel,
		                                               n_planes,
		                                               method);
		//VOXEL(out_volume, x, y, z) = ((float)z/(float)volume_zsize) * 255;
		//VOXEL(out_volume, x,y,z) = 1;
		
	}
}
	
