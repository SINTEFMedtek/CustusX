// This file is part of CustusX, an Image Guided Therapy Application.
//
// Copyright (C) 2008- SINTEF Technology & Society, Medical Technology
//
// CustusX is fully owned by SINTEF Medical Technology (SMT). CustusX source
// code and binaries can only be used by SMT and those with explicit permission
// from SMT. CustusX shall not be distributed to anyone else.
//
// CustusX is a research tool. It is NOT intended for use or certified for use
// in a normal clinical setting. SMT does not take responsibility for its use
// in any way.
//
// See CustusX_License.txt for more information.

#include <vtkPolyData.h>
#include <vtkPolyDataWriter.h>
#include <vtkCellArray.h>
#include "cxDataManager.h"
#include "sscMesh.h"
#include "sscVector3D.h"
#include "cxDataLocations.h"
#include "vesselReg/SeansVesselReg.hxx"
#include "sscRegistrationTransform.h"
#include "sscTypeConversions.h"
#include <QFileInfo>
#include <QDir>
#include "sscXmlOptionItem.h"

#include "catch.hpp"

#include "sscLogger.h"
#include "sscTime.h"
#include "cxDataLocations.h"
#include "cxElastixExecuter.h"
#include "cxPatientService.h"
#include "cxPatientData.h"
#include "cxSettings.h"
#include "cxElastixSingleThreadedRunner.h"
#include "sscTypeConversions.h"
#include "cxElastixParameters.h"

namespace cxtest
{

/** 
 *
 *
 * \ingroup cx
 * \date 6/7/2013, 2013
 * \author christiana
 */

void setUp()
{
	ssc::MessageManager::initialize();
	cx::DataManager::initialize();
}

void tearDown()
{
	ssc::DataManager::shutdown();
	ssc::MessageManager::shutdown();
}

bool compareTransforms(ssc::Transform3D result, ssc::Transform3D solution)
{
	std::cout << "result\n" << result << std::endl;
	std::cout << "solution\n" << solution << std::endl;

	ssc::Transform3D diff = solution * result.inv();

	std::cout << "diff\n" << diff << std::endl;

	ssc::Vector3D t_delta = diff.matrix().block<3, 1>(0, 3);
	Eigen::AngleAxisd angleAxis = Eigen::AngleAxisd(diff.matrix().block<3, 3>(0, 0));
	double angle = angleAxis.angle();

	ssc::Vector3D shift = diff.coord(ssc::Vector3D(0,0,0));


	QString res = QString(""
		"Shift vector (r):\t%1\n"
		"Accuracy |v|:\t%2mm\n"
		"Angle:       \t%3*\n"
		"")
		.arg(qstring_cast(shift))
		.arg(shift.length(), 6, 'f', 2)
		.arg(angle / M_PI * 180.0, 6, 'f', 2);

	std::cout << res << std::endl;

	return (fabs(angle/M_PI*180.0) < 0.1) && (shift.length() < 0.1);
}

void testElastix()
{
	QString kaisa_padded_fname = cx::DataLocations::getTestDataPath() + "/testing/elastiX/kaisa_padded.mhd";
	QString kaisa_resliced_fname = cx::DataLocations::getTestDataPath() + "/testing/elastiX/kaisa_resliced.mhd";
	QString kaisa_resliced_linear_fname = cx::DataLocations::getTestDataPath() + "/testing/elastiX/kaisa_resliced_linear.mhd";

	ssc::DataPtr kaisa_resliced_linear = ssc::dataManager()->loadData("source_"+kaisa_resliced_linear_fname, kaisa_resliced_linear_fname, ssc::rtAUTO);
	ssc::DataPtr kaisa_padded = ssc::dataManager()->loadData("source_"+kaisa_padded_fname, kaisa_padded_fname, ssc::rtAUTO);
	ssc::DataPtr kaisa_resliced = ssc::dataManager()->loadData("source_"+kaisa_resliced_fname, kaisa_resliced_fname, ssc::rtAUTO);

	QString elastixPreset = "elastix/p_Rigid"; // this is an autogenerated preset

	ssc::Transform3D solution;
	solution.matrix() <<
				1, 0 ,0, 10,
				0, 1, 0,  5,
				0, 0, 1, -2,
				0, 0, 0,  1;

	ssc::Transform3D result = ssc::Transform3D::Identity();

	cx::ElastixParametersPtr parameters(new cx::ElastixParameters(ssc::XmlOptionFile()));
	parameters->getCurrentPreset()->setValue(elastixPreset);

	cx::ElastixSingleThreadedRunner runner;
	runner.registerLinear(kaisa_padded, kaisa_resliced_linear, parameters, &result);

	REQUIRE(compareTransforms(result, solution) == true);
}

TEST_CASE("ElastiX should register kaisa to a translated+resampled version of same", "[pluginRegistration][integration]"){
	testElastix();
}


} // namespace cxtest


